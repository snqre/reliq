{"version":3,"sources":["../../src/util/to_string.ts","../../src/util/clone.ts","../../src/math/fpv.ts","../../src/error_handler/option.ts","../../src/error_handler/error.ts","../../src/error_handler/unsafe.ts","../../src/error_handler/shortcut.ts","../../src/error_handler/some.ts","../../src/error_handler/variant/dom_error.ts","../../src/error_handler/none.ts","../../src/error_handler/ok.ts","../../src/error_handler/result.ts","../../src/error_handler/err.ts","../../src/meta/internal_error_message.ts","../../src/util_interface/branded_struct.ts","../../src/util_interface/branded.ts","../../src/performance/object_pool/dyn.ts","../../src/eda/ref.ts"],"sourcesContent":["/** \n * ***Brief***\n * Converts `unknown` to `string`.\n * \n * ***Warning***\n * Does not support circular references and circular objects will result in `[object Object]`.\n * \n * ***Example***\n *  ```ts\n *  console.log(toString(42));          /// 42\n *  console.log(toString(true));        /// true\n *  console.log(toString(null));        /// null\n *  console.log(toString(undefined));   /// undefined\n * \n *  console.log(toString(\"example\"));   /// example\n * \n *  let object: {\n *      color: string;\n *      speed: {\n *          min: number,\n *          max: number\n *      }\n *  } = {\n *      color: \"Blue\",\n *      speed: {\n *          min: 0,\n *          max: 500\n *      }\n *  };\n *  console.log(object);                /// {\"color\":\"Blue\",\"speed\":{\"min\":0,\"max\":500}}\n * \n *  function foo(): void {\n *      let x: string = 500;\n *      return x;\n *  }\n *  console.log(foo);                   /// function foo() {\n *                                      ///     x = 500;\n *                                      ///     return x;\n *                                      /// }\n *  ```\n */\nexport function toString(unknown: unknown): string {\n    if (unknown === null || unknown === undefined || typeof unknown !== \"object\") return String(unknown);\n    try {\n        return JSON.stringify(unknown);\n    }\n    catch {}\n    return \"[object Object]\";\n}","import {\n    type Result,\n    DomError,\n    wrap,\n} from \"@\";\n\n/**\n * ***Brief***\n * Creates a deep clone of the provided value using the structuredClone API.\n * \n * ***Example***\n * ```ts\n *  clone()\n *      .resolve(e => {\n *          if (e.code === \"DOM.ERR_DATA_CLONE\") {\n *              /// ...\n *          }\n *      })\n *      .unlock();\n * ```\n */\nexport function clone<T1>(value: T1): Result<T1, DomError> {\n    return wrap(() => {\n        return structuredClone(value);\n    }).mapErr(unsafe => {\n        return unsafe\n            .parse((instance): instance is DOMException => {\n                return instance !== null\n                    && instance !== undefined\n                    && typeof instance === \"object\"\n                    && \"name\" in instance\n                    && \"code\" in instance\n                    && \"message\" in instance\n                    && typeof instance.name === \"string\"\n                    && typeof instance.code === \"number\"\n                    && typeof instance.message === \"string\";\n            })\n            .map(exception => {\n                return DomError(exception);\n            })\n            .unwrapOr(DomError());\n    });\n}","import {\n    INTERNAL_ERROR_MESSAGE,\n    Result,\n    Ok,\n    Err\n} from \"@\";\n\ntype Result$0<T1, T2> = Result<T1, T2>;\n\nexport type Fpv<T1 extends Fpv.Decimals> = {\n\n    /**\n     * ***Brief***\n     * Unwraps the wrapped value of type `T1`.\n     * \n     * ***Requirement***\n     * Does not `panic`.\n     * \n     * ***Example***\n     * ```ts\n     *  let unsafe: Unsafe = Unsafe(500n);\n     *  unsafe.unwrap();\n     * ```\n     */\n    unwrap(): bigint;\n\n    decimals(): T1;\n    representation(): bigint;\n    eq(x: bigint): boolean;\n    eq(x: Fpv<T1>): boolean;\n    eq(x: Fpv.Compatible<T1>): boolean;\n    lt(x: bigint): boolean;\n    lt(x: Fpv<T1>): boolean;\n    lt(x: Fpv.Compatible<T1>): boolean;\n    gt(x: bigint): boolean;\n    gt(x: Fpv<T1>): boolean;\n    gt(x: Fpv.Compatible<T1>): boolean;\n    lteq(x: bigint): boolean;\n    lteq(x: Fpv<T1>): boolean;\n    lteq(x: Fpv.Compatible<T1>): boolean;\n    gteq(x: bigint): boolean;\n    gteq(x: Fpv<T1>): boolean;\n    gteq(x: Fpv.Compatible<T1>): boolean;\n    add(x: bigint): Fpv<T1>;\n    add(x: Fpv<T1>): Fpv<T1>;\n    add(x: Fpv.Compatible<T1>): Fpv<T1>;\n    sub(x: bigint): Fpv<T1>;\n    sub(x: Fpv<T1>): Fpv<T1>;\n    sub(x: Fpv.Compatible<T1>): Fpv<T1>;\n    mul(x: bigint): Fpv<T1>;\n    mul(x: Fpv<T1>): Fpv<T1>;\n    mul(x: Fpv.Compatible<T1>): Fpv<T1>;\n    div(x: bigint): Fpv.Result<Fpv<T1>>;\n    div(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    div(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    pow(x: bigint): Fpv.Result<Fpv<T1>>;\n    pow(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    pow(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    sqrt(): Fpv.Result<Fpv<T1>>;\n    convert<T2 extends Fpv.Decimals>(decimals: T2): Fpv.Result<Fpv<T2>>;\n    percentageOf(x: bigint): Fpv.Result<Fpv<T1>>;\n    percentageOf(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    percentageOf(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    percentageGain(newValue: bigint): Fpv.Result<Fpv<T1>>;\n    percentageGain(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    percentageGain(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    percentageLoss(newValue: bigint): Fpv.Result<Fpv<T1>>;\n    percentageLoss(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    percentageLoss(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    percentageChange(newValue: bigint): Fpv.Result<Fpv<T1>>;\n    percentageChange(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    percentageChange(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    sliceOf(percentage: bigint): Fpv.Result<Fpv<T1>>;\n    sliceOf(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    sliceOf(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    addPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\n    addPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    addPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    subPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\n    subPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    subPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\n    toNumber(): number;\n};\n\n/**\n * ***Warning***\n * Does not support negative `decimals`.\n */\nexport function Fpv<T1 extends Fpv.Decimals>(_v: Fpv.Compatible<T1>, _decimals: T1): Fpv.Result<Fpv<T1>> {\n    /***/ {\n        if (decimals() < 0n) return Err(\"FPV.ERR_NEGATIVE_DECIMALS\");\n        return Ok({\n            unwrap,\n            decimals,\n            representation,\n            eq,\n            lt,\n            gt,\n            lteq,\n            gteq,\n            add,\n            sub,\n            mul,\n            div,\n            pow,\n            sqrt,\n            convert,\n            percentageOf,\n            percentageGain,\n            percentageLoss,\n            percentageChange,\n            sliceOf,\n            addPercentage,\n            subPercentage,\n            toNumber\n        });\n    }\n\n    function unwrap(): bigint {\n        return Fpv.Calculator.unwrap(_v);\n    }\n\n    function decimals(): T1 {\n        return _decimals;\n    }\n\n    function representation(): bigint {\n        return 10n ** decimals();\n    }\n\n    function eq(x: bigint): boolean;\n    function eq(x: Fpv<T1>): boolean;\n    function eq(x: Fpv.Compatible<T1>): boolean {\n        return Fpv.Calculator.eq(_v, x);\n    }\n\n    function lt(x: bigint): boolean;\n    function lt(x: Fpv<T1>): boolean;\n    function lt(x: Fpv.Compatible<T1>): boolean {\n        return Fpv.Calculator.lt(_v, x);\n    }\n\n    function gt(x: bigint): boolean;\n    function gt(x: Fpv<T1>): boolean;\n    function gt(x: Fpv.Compatible<T1>): boolean {\n        return Fpv.Calculator.gt(_v, x);\n    }\n\n    function lteq(x: bigint): boolean;\n    function lteq(x: Fpv<T1>): boolean;\n    function lteq(x: Fpv.Compatible<T1>): boolean {\n        return Fpv.Calculator.lteq(_v, x);\n    }\n\n    function gteq(x: bigint): boolean;\n    function gteq(x: Fpv<T1>): boolean;\n    function gteq(x: Fpv.Compatible<T1>): boolean {\n        return Fpv.Calculator.gteq(_v, x);\n    }\n\n    function add(x: bigint): Fpv<T1>;\n    function add(x: Fpv<T1>): Fpv<T1>;\n    function add(x: Fpv.Compatible<T1>): Fpv<T1> {\n        return Fpv.Calculator\n            .add(_v, x, decimals())\n            .expect(INTERNAL_ERROR_MESSAGE);\n    }\n\n    function sub(x: bigint): Fpv<T1>;\n    function sub(x: Fpv<T1>): Fpv<T1>;\n    function sub(x: Fpv.Compatible<T1>): Fpv<T1> {\n        return Fpv.Calculator\n            .sub(_v, x, decimals())\n            .expect(INTERNAL_ERROR_MESSAGE);\n    }\n\n    function mul(x: bigint): Fpv<T1>;\n    function mul(x: Fpv<T1>): Fpv<T1>;\n    function mul(x: Fpv.Compatible<T1>): Fpv<T1> {\n        return Fpv.Calculator\n            .mul(_v, x, decimals())\n            .expect(INTERNAL_ERROR_MESSAGE);\n    }\n\n    function div(x: bigint): Fpv.Result<Fpv<T1>>;\n    function div(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function div(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.div(_v, x, decimals());\n    }\n\n    function pow(x: bigint): Fpv.Result<Fpv<T1>>;\n    function pow(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function pow(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.pow(_v, x, decimals());\n    }\n\n    function sqrt(): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.sqrt(_v, decimals());\n    }\n\n    function convert<T2 extends Fpv.Decimals>(decimals$0: T2): Fpv.Result<Fpv<T2>> {\n        return Fpv.Calculator.convert(_v, decimals(), decimals$0);\n    }\n\n    function percentageOf(x: bigint): Fpv.Result<Fpv<T1>>;\n    function percentageOf(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function percentageOf(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.percentageOf(_v, x, decimals());\n    }\n\n    function percentageGain(newValue: bigint): Fpv.Result<Fpv<T1>>;\n    function percentageGain(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function percentageGain(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.percentageGain(_v, newValue, decimals());\n    }\n\n    function percentageLoss(newValue: bigint): Fpv.Result<Fpv<T1>>;\n    function percentageLoss(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function percentageLoss(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.percentageLoss(_v, newValue, decimals());\n    }\n\n    function percentageChange(newValue: bigint): Fpv.Result<Fpv<T1>>;\n    function percentageChange(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function percentageChange(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.percentageChange(_v, newValue, decimals());\n    }\n\n    function sliceOf(percentage: bigint): Fpv.Result<Fpv<T1>>;\n    function sliceOf(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function sliceOf(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.sliceOf(_v, percentage, decimals());\n    }\n\n    function addPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\n    function addPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function addPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.addPercentage(_v, percentage, decimals());\n    }\n\n    function subPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\n    function subPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\n    function subPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\n        return Fpv.Calculator.subPercentage(_v, percentage, decimals());\n    }\n\n    function toNumber(): number {\n        return Number(_v) / Number(10n**decimals());\n    }\n}\n\nexport namespace Fpv {\n    export type Result<T1> = Result$0<T1, ErrorCode>;\n\n    export type ErrorCode = \n        | \"FPV.ERR_DIVISION_BY_ZERO\"\n        | \"FPV.ERR_NEGATIVE_DECIMALS\"\n        | \"FPV.ERR_NEGATIVE_EXPONENT\"\n        | \"FPV.ERR_CANNOT_SQUARE_NAGATIVE\";\n\n    export type Compatible<T1 extends Decimals = Decimals> = Fpv<T1> | bigint;\n\n    export type Decimals = bigint;\n\n    export type Calculator = {\n        unwrap(value: Compatible<Decimals>): bigint;\n        eq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        eq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        eq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        eq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\n        eq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\n        lt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        lt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        lt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        lt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\n        lt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\n        gt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        gt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        gt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        gt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\n        gt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\n        lteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        lteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        lteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\n        lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\n        gteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        gteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        gteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\n        gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\n        add<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        add<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        add<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        add<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        add<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        sub<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        sub<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        sub<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        sub<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        sub<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        mul<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        mul<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        mul<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        mul<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        mul<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        div<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        div<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        div<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        div<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        div<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        pow<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        pow<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        pow<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        pow<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        pow<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        sqrt<T1 extends Decimals>(x: bigint, decimals: T1): Result<Fpv<T1>>;\n        sqrt<T1 extends Decimals>(x: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        sqrt<T1 extends Decimals>(x: Compatible<T1>, decimals: T1): Result<Fpv<T1>>; \n        convert<T1 extends Decimals, T2 extends Decimals>(x: bigint, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\n        convert<T1 extends Decimals, T2 extends Decimals>(x: Fpv<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\n        convert<T1 extends Decimals, T2 extends Decimals>(x: Compatible<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\n        percentageOf<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageOf<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageOf<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageGain<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageLoss<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageChange<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;        \n        sliceOf<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        sliceOf<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        sliceOf<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        addPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        addPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        addPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n        subPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        subPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        subPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\n    };\n\n    export const Calculator: Calculator = (() => {\n        /***/ {\n            return {\n                unwrap,\n                eq,\n                lt,\n                gt,\n                lteq,\n                gteq,\n                add,\n                sub,\n                mul,\n                div,\n                pow,\n                sqrt,\n                convert,\n                percentageOf,\n                percentageGain,\n                percentageLoss,\n                percentageChange,\n                sliceOf,\n                addPercentage,\n                subPercentage\n            };\n        }\n\n        function unwrap(value: Compatible<Decimals>): bigint {\n            return typeof value === \"bigint\" ? value : value.unwrap();\n        }\n\n        function eq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        function eq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        function eq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        function eq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\n        function eq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\n            return unwrap(x) === unwrap(y);\n        }\n\n        function lt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        function lt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        function lt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        function lt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\n        function lt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\n            return unwrap(x) < unwrap(y);\n        }\n\n        function gt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        function gt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        function gt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        function gt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\n        function gt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\n            return unwrap(x) > unwrap(y);\n        }\n\n        function lteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        function lteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        function lteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        function lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\n        function lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\n            return unwrap(x) <= unwrap(y);\n        }\n\n        function gteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\n        function gteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\n        function gteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\n        function gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\n        function gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\n            return unwrap(x) >= unwrap(y);\n        }\n\n        function add<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function add<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function add<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function add<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        function add<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            return Fpv<T1>(unwrap(x) + unwrap(y), decimals);\n        }\n\n        function sub<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function sub<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function sub<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function sub<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        function sub<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            return Fpv<T1>(unwrap(x) - unwrap(y), decimals);\n        }\n\n        function mul<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function mul<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function mul<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function mul<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        function mul<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            let y$0: bigint = unwrap(y);\n            let z: bigint = x$0 * y$0;\n            if (decimals === 0n) return Fpv<T1>(z, decimals);\n            return Fpv<T1>(z / (10n ** decimals), decimals);\n        }\n\n        function div<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function div<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function div<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function div<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        function div<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            let y$0: bigint = unwrap(y);\n            if (y$0 === 0n) return Err(\"FPV.ERR_DIVISION_BY_ZERO\");\n            if (decimals === 0n) return Ok(Fpv(x$0 / y$0, decimals).expect(INTERNAL_ERROR_MESSAGE));    \n            let z: bigint = x$0 * (10n ** decimals);\n            let q: bigint = z / y$0;\n            return Ok(Fpv(q, decimals).expect(INTERNAL_ERROR_MESSAGE));\n        }\n\n        function pow<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function pow<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function pow<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function pow<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\n        function pow<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let base: bigint = unwrap(x);\n            let exponent: bigint = unwrap(y);\n            if (exponent < 0n) return Err(\"FPV.ERR_NEGATIVE_EXPONENT\");\n            let result: bigint = 1n;\n            while (exponent > 0n) {\n                if (exponent % 2n === 1n) result = (result * base) / (10n ** decimals);\n                base = (base * base) / (10n ** decimals);\n                exponent /= 2n;\n            }\n            let result$0: Result<Fpv<T1>> = convert(result, 0n, decimals);\n            if (result$0.err()) return result$0;\n            let result$1: Fpv<T1> = result$0.unwrap();\n            let result$2: bigint = result$1.unwrap();\n            return Fpv(result$2, decimals);\n        }\n\n        function sqrt<T1 extends Decimals>(x: bigint, decimals: T1): Result<Fpv<T1>>;\n        function sqrt<T1 extends Decimals>(x: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function sqrt<T1 extends Decimals>(x: Compatible<T1>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            if (x$0 < 0n) return Err(\"FPV.ERR_CANNOT_SQUARE_NAGATIVE\");\n            if (x$0 === 0n) return Fpv(0n, decimals);\n            let one: bigint = 10n ** decimals;\n            one *= x$0;\n            let x$1: bigint = one;\n            let y: bigint;\n            do {\n                y = x$1;\n                x$1 = (y + one / y) / 2n; \n            }\n            while(x$1 !== y);\n            return Fpv(x$1, decimals);\n        }\n\n        function convert<T1 extends Decimals, T2 extends Decimals>(x: bigint, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\n        function convert<T1 extends Decimals, T2 extends Decimals>(x: Fpv<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\n        function convert<T1 extends Decimals, T2 extends Decimals>(x: Compatible<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>> {\n            if (oldDecimals < 0n) return Err(\"FPV.ERR_NEGATIVE_DECIMALS\");\n            if (newDecimals < 0n) return Err(\"FPV.ERR_NEGATIVE_DECIMALS\");\n            let x$0: bigint = unwrap(x);\n            let scl: bigint;\n            if (newDecimals > oldDecimals) {\n                scl = 10n ** (newDecimals - oldDecimals as unknown as bigint);\n                x$0 *= scl;\n            }\n            if (newDecimals < oldDecimals) {\n                scl = 10n ** (oldDecimals - newDecimals as unknown as bigint);\n                x$0 /= scl;\n            }\n            return Ok(Fpv(x$0, newDecimals).expect(INTERNAL_ERROR_MESSAGE));\n        }\n\n        function percentageOf<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageOf<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageOf<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            let y$0: bigint = unwrap(y);\n            return div(x$0, y$0, decimals)\n                .map(value => {\n                    return value.unwrap();\n                })\n                .and(value => {\n                    return mul(value, 100n * (10n**decimals), decimals);\n                });\n        }\n\n        function percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageGain<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let oldValue$0: bigint = unwrap(oldValue);\n            let newValue$0: bigint = unwrap(newValue);\n            if (newValue$0 <= oldValue$0) return Fpv(0n, decimals);\n            return sub(newValue$0, oldValue$0, decimals)\n                .and(value => {\n                    return div(value, oldValue$0, decimals);\n                })\n                .and(value => {\n                    return mul(value, 100n * (10n**decimals), decimals);\n                })\n                .mapErr(e => {\n                    return e as ErrorCode;\n                });\n        }\n\n        function percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageLoss<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let oldValue$0: bigint = unwrap(oldValue);\n            let newValue$0: bigint = unwrap(newValue);\n            if (newValue$0 >= oldValue$0) return Fpv(0n, decimals);\n            return sub(newValue$0, oldValue$0, decimals)\n                .and(value => {\n                    return div(value, oldValue$0, decimals)\n                })\n                .and(value => {\n                    return mul(value, 100n * (10n**decimals), decimals);\n                })\n                .mapErr(e => {\n                    return e as ErrorCode;\n                });\n        }\n\n        function percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageChange<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\n        function percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let oldValue$0: bigint = unwrap(oldValue);\n            let newValue$0: bigint = unwrap(newValue);\n            if (newValue$0 <= oldValue$0) return percentageLoss(oldValue$0, newValue$0, decimals);\n            return percentageGain(oldValue$0, newValue$0, decimals);\n        }\n\n        function sliceOf<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        function sliceOf<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        function sliceOf<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            let percentage$0: bigint = unwrap(percentage);\n            let z: Result<Fpv<T1>> = div<T1>(x$0, 100n * (10n**decimals), decimals);\n            if (z.err()) return z;\n            let z$0: Fpv<T1> = z.unwrap();\n            return mul(z$0, percentage$0, decimals);\n        }\n\n        function addPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        function addPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        function addPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            let percentage$0: bigint = unwrap(percentage);\n            return sliceOf(x$0, percentage$0, decimals).and(y => {\n                return add(x$0, y, decimals);\n            });\n        }\n\n        function subPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        function subPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\n        function subPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\n        function subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\n            let x$0: bigint = unwrap(x);\n            let percentage$0: bigint = unwrap(percentage);\n            return sliceOf(x$0, percentage$0, decimals).and(y => {\n                return sub(x$0, y, decimals);\n            });\n        }\n    })();\n}","import {\n    Some,\n    None\n} from \"@\";\n\ntype Array$0<T1> = Array<T1>;\n\n/**\n * ***Brief***\n * A type that represents an optional value, encapsulating either a value `Some` \n * or the absence of a value `None`.\n */\nexport type Option<T1> = Some<T1> | None;\n\nexport namespace Option {\n    export type Async<T1> = Promise<Option<T1>>;\n\n    export type Array<T1> = Array$0<Option<T1>>;\n\n    /**\n     * ***Brief***\n     * Utility class for handling tasks within `Option`.\n     */\n    export type Handler = {\n        /**\n         * ***Brief***\n         * Wraps a value into an `Option`, turning `null` or `undefined` to `None`.\n         * \n         * ***Example***\n         * ```ts\n         *  let foo: string | undefined;\n         *  Option\n         *      .flag(foo)\n         *      .map(foo => {\n         *          /// ...\n         *      });\n         * ```\n         */\n        flag<T1>(value: T1 | null | undefined): Option<T1>;\n\n        /**\n         * ***Brief***\n         * Iterates through an array of `Option`, short-circuiting at the first `None`.\n         * \n         * ***Example***\n         * ```ts\n         *  let o0: Option<200n>;\n         *  let o1: Option<201n>;\n         *  let o2: Option<202n>;\n         *  let o: Option<[200n, 201n, 202n]> = Option.all([o0, o1, o2]);\n         * ```\n         */\n        all<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>>;\n        \n        /**\n         * ***Brief***\n         * Iterates through an array of `Option`, short-circuiting at the first `Some`.\n         * \n         * ***Example***\n         * ```ts\n         *  let o0: Option<200n>;\n         *  let o1: Option<201n>;\n         *  let o2: Option<202n>;\n         *  let o: Option<200n | 201n | 202n> = Option.any([o0, o1, o2]);\n         * ```\n         */\n        any<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>[number]>;\n    };\n\n    export const Handler: Handler = (() => {\n        { return { flag, all, any }; }\n\n        function flag<T1>(value: T1 | null | undefined): Option<T1> {\n            if (value === null) return None;\n            if (value === undefined) return None;\n            return Some((value as T1));\n        }\n\n        function all<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>> {\n            let out: Array$0<unknown> = [];\n            let i: number = 0;\n            while (i < options.length) {\n                let option: Option<unknown> = options.at(i)!;\n                if (option.none()) return option as None;\n                out.push(option.unwrap());\n                i ++;\n            }\n            return Some(out as Some.ValFromAll<T1>);\n        }\n\n        function any<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>[number]> {\n            let i: number = 0;\n            while (i < options.length) {\n                let option: Option<unknown> = options.at(i)!;\n                if (option.some()) return option as Some<Some.ValFromAll<T1>[number]>;\n                i ++;\n            }\n            return None;\n        }\n    })();\n}","import {\n    type Closure,\n    BrandedStruct,\n    Option,\n    Some,\n    None,\n    flag,\n} from \"@\";\n\ntype Array$0<T1> = Array<T1>;\n\nexport type Error<T1 extends string, T2 = unknown> = \n    & BrandedStruct<\"Error\">\n    & {\n\n    /**\n     * ***Brief***\n     * The unique identifier for this error.\n     */\n    code: T1;\n\n    /**\n     * ***Brief***\n     * A human-readable message that explains the nature of the error.\n     */\n    message: Option<string>;\n\n    /**\n     * ***Brief***\n     * An optional value that can hold additional data or context related to the error.\n     */\n    payload: Option<T2>;\n\n    /**\n     * ***Brief***\n     * The stack trace associated with the error.\n     */\n    stack: string;\n};\n\n/**\n * ***Brief***\n * A custom error with an optional message and payload for strongly-typed errors.\n * \n * ***Note***\n * This is a general-purpose error structure to manage domain-specific error codes and provide better context.\n */\nexport function Error<T1 extends string, T2 = unknown>(_configuration: Error.Configuration<T1, T2>): Error<T1, T2>;\nexport function Error<T1 extends string, T2 = unknown>(_code: T1, _message?: string, _payload?: T2): Error<T1, T2>;\nexport function Error<T1 extends string, T2 = unknown>(\n    _p0: Error.Configuration<T1, T2> | T1,\n    _p1?: string,\n    _p2?: T2\n): Error<T1, T2> {\n    /** @constructor */ {\n        if (typeof _p0 === \"object\") {\n            let configuration: Error.Configuration<T1, T2> = _p0;\n            let handler: Error.Handler = flag(configuration.handler).unwrapOr(Error.Handler);\n            return {\n                type: \"Error\",\n                code: configuration.code,\n                message: Option.Handler.flag(configuration.message),\n                payload: Option.Handler.flag(configuration.payload),\n                stack: Option.Handler.flag(configuration.stack).unwrapOr(handler.localStackTrace(Error).unwrapOr(\"\"))\n            };\n        }\n        return {\n            type: \"Error\",\n            code: _p0,\n            message: Option.Handler.flag(_p1),\n            payload: Option.Handler.flag(_p2),\n            stack: Error.Handler.localStackTrace(Error).unwrapOr(\"\")\n        };\n    }\n}\n\nexport namespace Error {\n    export type Configuration<T1 extends string, T2 = unknown> = {\n        code: T1;\n        message?: string;\n        payload?: T2;\n        stack?: string;\n        handler?: Error.Handler;\n    };\n\n    export type Task<T1 extends string, T2 = unknown> = Closure<[e: Error<T1, T2>], void>;\n\n    export type Handler = {\n        match(unknown: unknown): unknown is Error<any, unknown>;\n        match(unknown: unknown, task: Task<any>): unknown is Error<any, unknown>;\n        match<T1 extends string>(unknown: unknown, code: T1): unknown is Error<T1, unknown>;\n        match<T1 extends string>(unknown: unknown, code: T1, task: Task<T1>): unknown is Error<T1, unknown>;\n\n        /**\n         * ***Brief***\n         * `panic` throws an error with optional message and stack trace location.\n         * \n         * ***Example***\n         * ```ts\n         *  panic(Error(\"MATH.ERR_DIVISION_BY_ZERO\"));\n         *  panic(Error({\n         *      code: \"MATH.ERR_DIVISION_BY_ZERO\",\n         *      message: Some(\"Math: Cannot divide by zero.\"),\n         *      payload: None,\n         *      stack: StackTrace(...)\n         *  }));\n         *  panic(\"An unrecoverable error has occured.\");\n         * ```\n         */\n        panic<T1 extends string>(e: Error<T1>, handler?: Handler): never;\n        panic<T1 extends string>(code: T1, at?: Function, handler?: Handler): never;\n        localStackTrace(at: Function): Option<string>;\n    };\n\n    export const Handler: Handler = (() => {\n        let _this: Handler;\n\n        /** @constructor */ {\n            return _this = { match, panic, localStackTrace };\n        }\n\n        function match(unknown: unknown): unknown is Error<any, unknown>;\n        function match(unknown: unknown, task: Task<any>): unknown is Error<any, unknown>;\n        function match<T1 extends string>(unknown: unknown, code: T1): unknown is Error<T1, unknown>;\n        function match<T1 extends string>(unknown: unknown, code: T1, task: Task<T1>): unknown is Error<T1, unknown>;\n        function match<T1 extends string>(\n            p0: unknown,\n            p1?: T1 | Closure<[e: Error<T1, unknown>], void>,\n            p2?: Closure<[e: Error<T1, unknown>], void>\n        ): p0 is Error<T1, unknown> {\n            let unknown: unknown = p0;\n            if (!BrandedStruct.Handler.match(unknown)) return false;\n            if (typeof p1 === \"string\") {\n                let code: T1 = p1;\n                if (!BrandedStruct.Handler.match(unknown, code)) return false;\n            }\n            let value: Error<T1> = (unknown as Error<T1>);\n            if (typeof p1 === \"function\") {\n                let task: Task<T1> = p1;\n                task(value);\n                return true;\n            }\n            if (typeof p2 === \"function\") {\n                let task: Task<T1> = p2;\n                task(value);\n                return true;\n            }\n            return true;\n        }\n\n        function panic<T1 extends string>(e: Error<T1>, handler?: Handler): never;\n        function panic<T1 extends string>(code: T1, at?: Function, handler?: Handler): never;\n        function panic<T1 extends string>(\n            p0: Error<T1> | T1,\n            p1?: Handler | Function,\n            p2?: Handler\n        ): never {\n            if (typeof p0 === \"object\") {\n                let e: Error<T1> = p0;\n                let shards: Array$0<string> = e.stack.split(\"\\n\");\n                shards.shift();\n                e.stack = shards.join(\"\\n\");\n                console.log(shards, \"ff\");\n                throw \"\\x1Bc\" + `\\x1B[31m${ e.code }: ${ e.message.unwrapOr(\"\") }\\x1B[0m` + \"\\n\" + `${ e.stack }`;\n            }\n            let code: T1 = p0;\n            let at: Function = flag((p1 as Function | undefined)).unwrapOr(panic);\n            let handler: Handler = flag(p2).unwrapOr(_this);\n            let stack: string = handler\n                .localStackTrace(at)\n                .toResult(None)\n                .map(stack => {\n                    let shards: Array$0<string> = stack.split(\"\\n\");\n                    shards.shift();\n                    return shards.join(\"\\n\");\n                })\n                .recover(() => {\n                    return \"<<< 404 >>>\";\n                })\n                .unwrap();\n                \n            throw \"\\x1Bc\" + `\\x1B[31m${ code }\\x1B[0m` + \"\\n\" + `${ stack }`;\n        }\n\n        function localStackTrace(location: Function): Option<string> {\n            let e: ReturnType<typeof globalThis.Error> = globalThis.Error();\n            globalThis.Error.captureStackTrace(e, location);\n            if (e.stack) return Some(e.stack);\n            return None;\n        }\n    })();\n}","import {\n    type TypeGuard,\n    type Option,\n    type Parsable,\n    Some,\n    None,\n} from \"@\";\n\nexport type Unsafe =\n    & Parsable\n    & {\n    inspect(): unknown;\n};\n\nexport function Unsafe(_value: unknown): Unsafe {\n    /***/ {\n        return { inspect, parse };\n    }\n\n    function inspect(): unknown {\n        return _value;\n    }\n\n    function parse<T1>(guard: TypeGuard<T1>): Option<T1> {\n        if (!guard(inspect())) return None;\n        return Some((inspect() as T1));\n    }\n}","import {\n    Option,\n    Result\n} from \"@\";\n\nexport const flag: typeof Option.Handler.flag = Option.Handler.flag;\n\nexport const allO: typeof Option.Handler.all = Option.Handler.all;\n\nexport const anyO: typeof Option.Handler.any = Option.Handler.any;\n\nexport const allR: typeof Result.Handler.all = Result.Handler.all;\n\nexport const anyR: typeof Result.Handler.any = Result.Handler.any;\n\nexport const wrap: typeof Result.Handler.wrap = Result.Handler.wrap;\n\nexport const wrapAsync: typeof Result.Handler.wrapAsync = Result.Handler.wrapAsync;","import {\n    type Branded,\n    type Closure,\n    type Option,\n    Ok,\n    None,\n\n} from \"@\";\n\nexport type Some<T1> = \n    & Branded<\"Some\">\n    & {\n\n    /**\n     * ***Brief***\n     * `some` checks if the current instance is `Some`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  if (option.some()) {\n     *      let value: 200n = option.unlock();\n     *      /// ...\n     *  }\n     * ```\n     */\n    some(): this is Some<T1>;\n\n    /**\n     * ***Brief***\n     * `none` checks if the current instance is `None`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  if (option.none()) {\n     *      /// `Option` cannot `unlock` because it is `None`.\n     *      /// ...\n     *  }\n     * ```\n     */\n    none(): this is None;\n\n    /**\n     * ***Brief***\n     * `expect` terminates with `panic` if the `Option` is `None`.\n     * \n     * ***Warning***\n     * Reserved for debugging or unrecoverable errors.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  let status: 200n = option.expect(\"This is unexpected and unrecoverable.\");\n     * ```\n     */\n    expect(): T1;\n    expect(__: unknown): T1;\n    expect(__?: unknown): T1;\n\n    /**\n     * ***Brief***\n     * Unwraps the wrapped value of type `T1`.\n     * \n     * ***Requirement***\n     * Does not `panic`.\n     * \n     * ***Example***\n     * ```ts\n     *  let unsafe: Unsafe = Unsafe(500n);\n     *  unsafe.unwrap();\n     * ```\n     */\n    unwrap(): T1;\n\n    /**\n     * ***Brief***\n     * Retrieves the value of a `Some`, or falls back to the provided value if its `None`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n> = None;\n     *  let status: 200n = option.unwrapOr(200n);\n     *  console.log(status); /// 200n.\n     * ```\n     */\n    unwrapOr(__: unknown): T1;\n\n    /**\n     * ***Brief***\n     * Chains an task until the first `None` is encountered.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n> = None;\n     *  option\n     *      .and(value => {\n     *          /// Task is skipped because `Option` is `None`.\n     *          /// ...\n     *          return Some(value + 1n);\n     *      })\n     *      .and(value => {\n     *          /// Task is skipped because `Option` is `None`.\n     *          /// ...\n     *      });\n     * ```\n     */\n    and<T2>(task: Closure<[T1], Option<T2>>): Option<T2>;\n\n    /**\n     * ***Brief***\n     * Transforms the `Some` value if present, but if this is already an `None`, it remains unchanged.\n     * \n     * ***Example***\n     * ```ts\n     *  let option0: Option<200n> = Some(200n);\n     *  let option1: Option<201n> = option.map(value => {\n     *      /// Task is run because `Option` is `Some`.\n     *      /// ...\n     *      return value + 1n;\n     *  });\n     * ```\n     */\n    map<T2>(task: Closure<[T1], T2>): Some<T2>;\n\n    /**\n     * ***Brief***\n     * Converts an `Option<T1>` to a `Result<T1, T2>`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  let result: Result<200n, 404n> = option.toResult(404n);\n     * ```\n     */\n    toResult(__: unknown): Ok<T1>;\n};\n\n/**\n * ***Brief***\n * The value within an `Option`.\n */\nexport function Some<T1>(_value: T1): Some<T1> {\n    /** @constructor */ {\n        return {\n            type,\n            some,\n            none,\n            expect,\n            unwrap,\n            unwrapOr,\n            and,\n            map,\n            toResult\n        };\n    }\n\n    function type(): \"Some\" {\n        return \"Some\";\n    }\n\n    function some(): this is Some<T1> {\n        return true;\n    }\n\n    function none(): this is None {\n        return false;\n    }\n\n    function expect(): T1;\n    function expect(__: unknown): T1;\n    function expect(__?: unknown): T1 {\n        return _value;\n    }\n\n    function unwrap(): T1 {\n        return _value;\n    }\n\n    function unwrapOr(__: unknown): T1 {\n        return _value;\n    }\n\n    function and<T2>(task: Closure<[T1], Option<T2>>): Option<T2> {\n        return task(_value);\n    }\n\n    function map<T2>(task: Closure<[T1], T2>): Some<T2> {\n        return Some(task(_value));\n    }\n\n    function toResult(__: unknown): Ok<T1> {\n        return Ok(_value);\n    }\n}\n\nexport namespace Some {\n    export type From<T1 extends Option<unknown>> = T1 extends Some<infer T2> ? Some<T2> : never;\n\n    export type FromAll<T1 extends Array<Option<unknown>>> = {\n        [T2 in keyof T1]: T1[T2] extends Some<unknown> ? From<T1[T2]> : never\n    };\n\n    export type ValFrom<T1 extends Option<unknown>> = T1 extends Some<infer T2> ? T2 : never;\n\n    export type ValFromAll<T1 extends Array<Option<unknown>>> = {\n        [T2 in keyof T1]: ValFrom<T1[T2]>;\n    };\n}","import { Error } from \"@\";\n\nexport type DomError = Error<DomError.Code>;\n\nexport function DomError(): DomError;\nexport function DomError(_legacy: DOMException): DomError;\nexport function DomError(\n    _p0?: DOMException\n): DomError {\n    {\n        let e: DOMException | undefined = _p0;\n        if (e) return Error(_match(e), e.message);\n        return Error(\"DOM.ERR_UNKNOWN\");\n    }\n\n    function _match(e: DOMException): DomError.Code {\n        let code: DomError.Code = \"DOM.ERR_UNKNOWN\";\n        if (\n            e.code === 1\n            || e.code === 3\n            || e.code === 4\n            || e.code === 5\n            || e.code === 7\n            || e.code === 8\n            || e.code === 9\n            || e.code === 11\n            || e.code === 12\n            || e.code === 13\n            || e.code === 14\n            || e.code === 17\n            || e.code === 18\n            || e.code === 19\n            || e.code === 20\n            || e.code === 21\n            || e.code === 22\n            || e.code === 23\n            || e.code === 24\n            || e.code === 25\n        ) code = DomError.Exception.CodeRemap[e.code];\n        else if (\n            e.name === \"EncodingError\"\n            || e.name === \"NotReadableError\"\n            || e.name === \"UnknownError\"\n            || e.name === \"ConstraintError\"\n            || e.name === \"DataError\"\n            || e.name === \"TransactionInactiveError\"\n            || e.name === \"ReadOnlyError\"\n            || e.name === \"VersionError\"\n            || e.name === \"OperationError\"\n            || e.name === \"NotAllowedError\"\n        ) code = DomError.Exception.NameRemap[e.name];\n        return code;\n    }\n}\n\nexport namespace DomError {\n    export type Code =\n        | \"DOM.ERR_INDEX_SIZE\"\n        | \"DOM.ERR_HIERARCHY_REQUEST\"\n        | \"DOM.ERR_WRONG_DOCUMENT\"\n        | \"DOM.ERR_INVALID_CHARACTER\"\n        | \"DOM.ERR_NO_MODIFICATION_ALLOWED\"\n        | \"DOM.ERR_NOT_FOUND\"\n        | \"DOM.ERR_NOT_SUPPORTED\"\n        | \"DOM.ERR_INVALID_STATE\"\n        | \"DOM.ERR_ATTRIBUTE_IN_USE\"\n        | \"DOM.ERR_SYNTAX\"\n        | \"DOM.ERR_INVALID_MODIFICATION\"\n        | \"DOM.ERR_NAMESPACE\"\n        | \"DOM.ERR_INVALID_ACCESS\"\n        | \"DOM.ERR_TYPE_MISMATCH\"\n        | \"DOM.ERR_SECURITY\"\n        | \"DOM.ERR_NETWORK\"\n        | \"DOM.ERR_ABORT\"\n        | \"DOM.ERR_URL_MISMATCH\"\n        | \"DOM.ERR_QUOTA_EXCEEDED\"\n        | \"DOM.ERR_TIMEOUT\"\n        | \"DOM.ERR_INVALID_NODE_TYPE\"\n        | \"DOM.ERR_DATA_CLONE\"\n        | \"DOM.ERR_ENCODING\"\n        | \"DOM.ERR_NOT_READABLE\"\n        | \"DOM.ERR_UNKNOWN\"\n        | \"DOM.ERR_CONSTRAINT\"\n        | \"DOM.ERR_DATA\"\n        | \"DOM.ERR_TRANSACTION_INACTIVE\"\n        | \"DOM.ERR_READ_ONLY\"\n        | \"DOM.ERR_VERSION\"\n        | \"DOM.ERR_OPERATION\"\n        | \"DOM.ERR_NOT_ALLOWED\";\n\n    export namespace Exception {\n        export const NameRemap: Record<Name, DomError.Code> = {\n            \"EncodingError\": \"DOM.ERR_ENCODING\",\n            \"NotReadableError\": \"DOM.ERR_NOT_READABLE\",\n            \"UnknownError\": \"DOM.ERR_UNKNOWN\",\n            \"ConstraintError\": \"DOM.ERR_CONSTRAINT\",\n            \"DataError\": \"DOM.ERR_DATA\",\n            \"TransactionInactiveError\": \"DOM.ERR_TRANSACTION_INACTIVE\",\n            \"ReadOnlyError\": \"DOM.ERR_READ_ONLY\",\n            \"VersionError\": \"DOM.ERR_VERSION\",\n            \"OperationError\": \"DOM.ERR_OPERATION\",\n            \"NotAllowedError\": \"DOM.ERR_NOT_ALLOWED\"\n        };\n\n        export const CodeRemap: Record<Code, DomError.Code> = {\n            1: \"DOM.ERR_INDEX_SIZE\",\n            3: \"DOM.ERR_HIERARCHY_REQUEST\",\n            4: \"DOM.ERR_WRONG_DOCUMENT\",\n            5: \"DOM.ERR_INVALID_CHARACTER\",\n            7: \"DOM.ERR_NO_MODIFICATION_ALLOWED\",\n            8: \"DOM.ERR_NOT_FOUND\",\n            9: \"DOM.ERR_NOT_SUPPORTED\",\n            11: \"DOM.ERR_INVALID_STATE\",\n            12: \"DOM.ERR_SYNTAX\",\n            13: \"DOM.ERR_INVALID_MODIFICATION\",\n            14: \"DOM.ERR_NAMESPACE\",\n            17: \"DOM.ERR_TYPE_MISMATCH\",\n            18: \"DOM.ERR_SECURITY\",\n            19: \"DOM.ERR_NETWORK\",\n            20: \"DOM.ERR_ABORT\",\n            21: \"DOM.ERR_URL_MISMATCH\",\n            22: \"DOM.ERR_QUOTA_EXCEEDED\",\n            23: \"DOM.ERR_TIMEOUT\",\n            24: \"DOM.ERR_INVALID_NODE_TYPE\",\n            25: \"DOM.ERR_DATA_CLONE\"\n        };\n\n        export type Name =\n            | \"EncodingError\"\n            | \"NotReadableError\"\n            | \"UnknownError\"\n            | \"ConstraintError\"\n            | \"DataError\"\n            | \"TransactionInactiveError\"\n            | \"ReadOnlyError\"\n            | \"VersionError\"\n            | \"OperationError\"\n            | \"NotAllowedError\";\n\n        export type Code =\n            | 1\n            | 3\n            | 4\n            | 5\n            | 7\n            | 8\n            | 9\n            | 11\n            | 12\n            | 13\n            | 14\n            | 17\n            | 18\n            | 19\n            | 20\n            | 21\n            | 22\n            | 23\n            | 24\n            | 25;\n    }\n}","import {\n    type Branded,\n    type Some,\n    Err,\n    Error,\n} from \"@\";\n\nexport type None = \n    & Branded<\"None\">\n    & {\n\n    /**\n     * ***Brief***\n     * `some` checks if the current instance is `Some`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  if (option.some()) {\n     *      let value: 200n = option.unlock();\n     *      /// ...\n     *  }\n     * ```\n     */\n    some(): this is Some<unknown>;\n\n    /**\n     * ***Brief***\n     * `none` checks if the current instance is `None`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  if (option.none()) {\n     *      /// `Option` cannot `unlock` because it is `None`.\n     *      /// ...\n     *  }\n     * ```\n     */\n    none(): this is None;\n    \n    /**\n     * ***Brief***\n     * `expect` terminates with `panic` if the `Option` is `None`.\n     * \n     * ***Warning***\n     * Reserved for debugging or unrecoverable errors.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  let status: 200n = option.expect(\"This is unexpected and unrecoverable.\");\n     * ```\n     */\n    expect(): never;\n    expect(message: string): never;\n    expect(message?: string): never;\n\n    /**\n     * ***Brief***\n     * Retrieves the value of a `Some`, or falls back to the provided value if its `None`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n> = None;\n     *  let status: 200n = option.unwrapOr(200n);\n     *  console.log(status); /// 200n.\n     * ```\n     */\n    unwrapOr<T2>(fallback: T2): T2;\n    \n    /**\n     * ***Brief***\n     * Chains an task until the first `None` is encountered.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n> = None;\n     *  option\n     *      .and(value => {\n     *          /// Task is skipped because `Option` is `None`.\n     *          /// ...\n     *          return Some(value + 1n);\n     *      })\n     *      .and(value => {\n     *          /// Task is skipped because `Option` is `None`.\n     *          /// ...\n     *      });\n     * ```\n     */\n    and(__: unknown): None;\n\n    /**\n     * ***Brief***\n     * Transforms the `Some` value if present, but if this is already an `None`, it remains unchanged.\n     * \n     * ***Example***\n     * ```ts\n     *  let option0: Option<200n> = Some(200n);\n     *  let option1: Option<201n> = option.map(value => {\n     *      /// Task is run because `Option` is `Some`.\n     *      /// ...\n     *      return value + 1n;\n     *  });\n     * ```\n     */\n    map(__: unknown): None;\n\n    /**\n     * ***Brief***\n     * Converts an `Option<T1>` to a `Result<T1, T2>`.\n     * \n     * ***Example***\n     * ```ts\n     *  let option: Option<200n>;\n     *  let result: Result<200n, 404n> = option.toResult(404n);\n     * ```\n     */\n    toResult<T1>(e: T1): Err<T1>;\n};\n\n/**\n * ***Brief***\n * The absence of a value or an \"empty\" state.\n * \n * ***Warning***\n * Any operation attempting to access an `Option` must safely handle the `None` state or terminate with an error.\n */\nexport const None: None = (() => {\n    let _this: None;\n\n    /** @constructor */ {\n        return _this = {\n            type,\n            some,\n            none,\n            expect,\n            unwrapOr,\n            and,\n            map,\n            toResult\n        };\n    }\n\n    function type(): \"None\" {\n        return \"None\";\n    }\n    \n    function some(): this is Some<unknown> {\n        return false;\n    }\n\n    function none(): this is None {\n        return true;\n    }\n\n    function expect(): never;\n    function expect(message: string): never;\n    function expect(message?: string): never {\n        Error.Handler.panic(Error({\n            code: \"PANIC\",\n            message: `${ message ? message : \"A missing value has caused the program to panic.\"}`,\n            stack: Error.Handler.localStackTrace(expect).unwrapOr(\"\")\n        }));\n    }\n\n    function unwrapOr<T1>(fallback: T1): T1 {\n        return fallback;\n    }\n\n    function and(__: unknown): None {\n        return _this;\n    }\n\n    function map(__: unknown): None {\n        return _this;\n    }\n\n    function toResult<T1>(e: T1): Err<T1> {\n        return Err(e);\n    }\n})();","import {\n    type Closure,\n    type Option,\n    type Result,\n    type Function as Function$0,\n    Error,\n    Err,\n    Some,\n} from \"@\";\n\nexport type Ok<T1> = {\n\n    /**\n     * ***Brief***\n     * `ok` checks if the current instance is `Ok`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  if (result.ok()) {\n     *      let value: 200n = result.unlock();\n     *      /// ...\n     *  }\n     * ```\n     */\n    ok(): this is Ok<T1>;\n\n    /**\n     * ***Brief***\n     * `err` checks if the current instance is `Err`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  if (result.err()) {\n     *      let e: 404n = result.inspect();\n     *      /// ...\n     *  }\n     * ```\n     */\n    err(): this is Err<unknown>;\n\n    /**\n     * ***Brief***\n     * `expect` terminates with `panic` if the `Result` is `Err`.\n     * \n     * ***Warning***\n     * Reserved for debugging or unrecoverable errors.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  let status: 200n = result.expect(\"This is unexpected and unrecoverable.\");\n     * ```\n     */\n    expect(): T1;\n    expect(__: unknown): T1;\n    expect(__?: unknown): T1;\n\n    /**\n     * ***Brief***\n     * Ensures that the `Result` is an `Err` and retrieves the error value inside.\n     * \n     * ***Warning***\n     * Reserved for debugging or unrecoverable errors.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  let status: 404n = result.expectErr(\"This is unexpected and unrecoverable.\");\n     * ```\n    */\n    expectErr(): never;\n    expectErr(message: string): never;\n    expectErr(message?: string): never;\n\n    /**\n     * ***Brief***\n     * Unwraps the wrapped value of type `T1`.\n     * \n     * ***Requirement***\n     * Does not `panic`.\n     * \n     * ***Example***\n     * ```ts\n     *  let unsafe: Unsafe = Unsafe(500n);\n     *  unsafe.unwrap();\n     * ```\n     */\n    unwrap(): T1;\n    \n    /**\n     * ***Brief***\n     * Retrieves the value of an `Ok`, or falls back to the provided value if its an `Err`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  let status: 200n = result.unwrapOr(200n);\n     *  console.log(status); /// 200n.\n     * ```\n     */\n    unwrapOr(__: unknown): T1;\n\n    /**\n     * ***Brief***\n     * Recovers from the current error by applying a recovery function, transforming the `Err` into an `Ok`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  let status: 200n = result\n     *      .recover(() => {\n     *          return 200n;\n     *      })\n     *      .unlock();\n     * ```\n     */\n    recover(__: unknown): Ok<T1>;\n\n    /**\n     * ***Brief***\n     * Applies a transformation to the `Ok` value and returns an `Err` instance with the transformed value.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Ok(200n);\n     *  let e: 404n = result\n     *      .degrade(() => {\n     *          return 404n;\n     *      })\n     *      .inspect();\n     *  console.log(e); /// 404n.\n     * ```\n     */\n    degrade<T2>(task: Function$0<T1, T2>): Err<T2>;\n\n    /**\n     * ***Brief***\n     * Chains an task until the first `Err` is encountered.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  result\n     *      .and(value => {\n     *          /// Task is skipped because `Result` is an `Err`.\n     *          /// ...\n     *          return Ok(value + 1n);\n     *      })\n     *      .and(value => {\n     *          /// Task is skipped because `Result` is an `Err`.\n     *          /// ...\n     *      });\n     * ```\n     */\n    and<T2>(task: Closure<[T1], Ok<T2>>): Ok<T2>;\n    and<T2>(task: Closure<[T1], Err<T2>>): Result<T1, T2>;\n    and<T2, T3>(task: Closure<[T1], Result<T2, T3>>): Result<T2, T3>;\n\n    /**\n     * ***Brief***\n     * Transforms the `Ok` value if present, but if this is already an `Err`, it remains unchanged.\n     * \n     * ***Example***\n     * ```ts\n     *  let result0: Result<200n, 404n> = Ok(200n);\n     *  let result1: Result<201n, 404n> = result.map(value => {\n     *      /// Task is run because `Result` is `Ok`.\n     *      /// ...\n     *      return value + 1n;\n     *  });\n     * ```\n     */\n    map<T2>(task: Closure<[T1], T2>): Ok<T2>;\n\n    /**\n     * ***Brief***\n     * Transforms the error contained in the `Err` using the provided `task` function.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  result\n     *      .mapErr(e => {\n     *          return e + 1n;\n     *      })\n     *      .inspect(); /// 405n.\n     * ```\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Ok(200n);\n     *  result\n     *      .mapErr(e => {\n     *          /// Task is run because `Result` is `Ok`.\n     *          /// ...\n     *      });\n     * ```\n     */\n    mapErr(__: unknown): Ok<T1>;\n\n    /**\n     * ***Brief***\n     * Converts a `Result<T1, T2>` to an `Option<T1>`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  let option: Option<200n> = result.toOption();\n     * ```\n     */\n    toOption(): Option<T1>;\n};\n\n/**\n * ***Brief***\n * The successful value within a `Result`.\n */\nexport function Ok<T1>(_value: T1): Ok<T1> {\n    let _this: Ok<T1>;\n\n    /** @constructor */ {\n        return _this = {\n            ok,\n            err,\n            expect,\n            expectErr,\n            unwrap,\n            unwrapOr,\n            and,\n            map,\n            mapErr,\n            recover,\n            degrade,\n            toOption\n        };\n    }\n\n    function ok(): this is Ok<T1> {\n        return true;\n    }\n\n    function err(): this is Err<unknown> {\n        return false;\n    }\n    \n    function expect(): T1;\n    function expect(__: unknown): T1;\n    function expect(__?: unknown): T1 {\n        return unwrap();\n    }\n\n    function expectErr(): never;\n    function expectErr(message: string): never;\n    function expectErr(message?: string): never {\n        Error.Handler.panic(Error(\"PANIC\", message));\n    }\n\n    function unwrap(): T1 {\n        return _value;\n    }\n\n    function unwrapOr(__: unknown): T1 {\n        return unwrap();\n    }\n\n    function and<T2>(task: Closure<[T1], Ok<T2>>): Ok<T2>;\n    function and<T2>(task: Closure<[T1], Err<T2>>): Result<T1, T2>;\n    function and<T2, T3>(task: Closure<[T1], Result<T2, T3>>): Result<T2, T3>;\n    function and<T2, T3>(task: Closure<[T1], Result<T2, T3>>): Result<T2, T3> {\n        return task(unwrap());\n    }\n\n    function map<T2>(task: Closure<[T1], T2>): Ok<T2> {\n        return Ok(task(unwrap()));\n    }\n\n    function mapErr(__: unknown): Ok<T1> {\n        return _this;\n    }\n\n    function recover(__: unknown): Ok<T1> {\n        return _this;\n    }\n\n    function degrade<T2>(task: Closure<[T1], T2>): Err<T2> {\n        return Err(task(unwrap()));\n    }\n\n    function toOption(): Option<T1> {\n        return Some(unwrap());\n    }\n}\n\nexport namespace Ok {\n    export type From<T1 extends Result<unknown, unknown>> = T1 extends Ok<infer T2> ? Ok<T2> : never;\n\n    export type FromAll<T1 extends Array<Result<unknown, unknown>>> = {\n        [T2 in keyof T1]: T1[T2] extends Ok<unknown> ? From<T1[T2]> : never;\n    };\n\n    export type ValFrom<T1 extends Result<unknown, unknown>> = T1 extends Ok<infer T2> ? T2 : never;\n\n    export type ValFromAll<T1 extends Array<Result<unknown, unknown>>> = {\n        [T2 in keyof T1]: ValFrom<T1[T2]>;\n    };\n}","import {\n    type Closure,\n    type AsyncClosure,\n    Ok,\n    Err,\n    Unsafe\n} from \"@\";\n\ntype Array$0<T1> = Array<T1>;\n\n/**\n * ***Brief***\n * A wrapper that encapsulates either a successful outcome `Ok<T1>` or a failure `Err<T2>`.\n * \n * ***Example***\n * ```ts\n *  function foo(): Result<200n, 404n> {\n *      if () return Ok(200n);\n *      return Err(404n);\n *  }\n * \n *  let result: Result<200n, 404n> = foo();\n *  if (result.ok()) {\n *      let value: 200n = result.unlock();\n *      /// ...\n *  }\n * ```\n */\nexport type Result<T1, T2> = Ok<T1> | Err<T2>;\n\nexport namespace Result {\n    export type Async<T1, T2> = Promise<Result<T1, T2>>;\n\n    export type Array<T1, T2> = Array$0<Result<T1, T2>>;\n\n    export type Handler = {\n        /**\n         * ***Brief***\n         * Iterates through an array of `Result`, short-circuiting at the first `Err`.\n         * \n         * ***Example***\n         * ```ts\n         * let r0: Result<200n, 404n>;\n         * let r1: Result<201n, 405n>;\n         * let r2: Result<202n, 406n>;\n         * let r: Result<[200n, 201n, 202n], 404n | 405n | 406n> = Result.all([r0, r1, r2]);\n         * ```\n         */\n        all<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>, Err.ValFromAll<T1>[number]>;\n        \n        /**\n         * ***Brief***\n         * Iterates through an array of `Result`, short-circuiting at the first `Ok`.\n         * \n         * ***Example***\n         * ```ts\n         *  let r0: Result<200n, 404n>;\n         *  let r1: Result<201n, 405n>;\n         *  let r2: Result<202n, 406n>;\n         *  let r: Result<200n | 201n | 202n, [404n, 405n, 406n]> = Result.any([r0, r1, r2]);\n         * ```\n         */\n        any<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>[number], Err.ValFromAll<T1>>;\n        \n        /**\n         * ***Brief***\n         * Wraps an unsafe operation that might throw an error and returns a `Result`.\n         * \n         * ***Example***\n         * ```ts\n         *  await Result.wrap(() => {\n         *      /// Some unsafe task.\n         *      /// ...\n         *      return 200n;\n         *  }).mapErr(unsafe => {\n         *      unsafe\n         *          .parse((unknown): unknown is string => {\n         *              return typeof unknown is \"string\";\n         *          })\n         *          .map(string => {\n         *              /// ...\n         *          });\n         *      return 200n;\n         *  });\n         * ```\n         */\n        wrap<T1, T2, T3 extends Array$0<T2>>(task: Closure<T3, T1>, ...payload: T3): Result<T1, Unsafe>;\n        \n        /**\n         * ***Brief***\n         * Wraps an asynchronous unsafe operation that may throw and returns a `Result`.\n         * \n         * \n         * ***Example***\n         * ```ts\n         *  await Result.wrapAsync(async () => {\n         *      /// Some unsafe async task.\n         *      /// ...\n         *      return 200n;\n         *  }).mapErr(unsafe => {\n         *      unsafe\n         *          .parse((unknown): unknown is string => {\n         *              return typeof unknown is \"string\";\n         *          })\n         *          .map(string => {\n         *              /// ...\n         *          });\n         *      return 200n;\n         *  });\n         * ```\n         */\n        wrapAsync<T1, T2, T3 extends Array$0<T2>>(task: AsyncClosure<T3, T1>, ...payload: T3): Promise<Result<T1, Unsafe>>;\n    };\n\n    export const Handler: Handler = (() => {\n        /** @constructor */ {\n            return { all, any, wrap, wrapAsync };\n        }\n\n        function all<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>, Err.ValFromAll<T1>[number]> {\n            let out: Array$0<unknown> = [];\n            let i: number = 0;\n            while (i < results.length) {\n                let result: Result<unknown, unknown> = results.at(i)!;\n                if (result.ok()) out.push(result.unwrap());\n                else return result as Err<Err.ValFromAll<T1>[number]>;\n                i ++;\n            }\n            return Ok((out as Ok.ValFromAll<T1>));\n        }\n    \n        function any<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>[number], Err.ValFromAll<T1>> {\n            let out: Array$0<unknown> = [];\n            let i: number = 0;\n            while (i < results.length) {\n                let wrapper: Result<unknown, unknown> = results.at(i)!;\n                if (wrapper.ok()) return wrapper as Ok<Ok.ValFromAll<T1>[number]>;\n                else out.push(wrapper.inspect());\n                i ++;\n            }\n            return Err((out as Err.ValFromAll<T1>));\n        }\n        \n        function wrap<T1, T2, T3 extends Array$0<T2>>(task: Closure<T3, T1>, ...payload: T3): Result<T1, Unsafe> {\n            try {\n                return Ok(task(...payload));\n            }\n            catch (e) {\n                return Err(Unsafe(e));\n            }\n        }\n    \n        async function wrapAsync<T1, T2, T3 extends Array$0<T2>>(task: AsyncClosure<T3, T1>, ...payload: T3): Promise<Result<T1, Unsafe>> {\n            try {\n                return Ok((await task(...payload)));\n            }\n            catch (e) {\n                return Err(Unsafe(e));\n            }\n        }\n    })();\n}\n","import {\n    type Closure,\n    type Option,\n    type Result,\n    Error,\n    None,\n    Ok,\n} from \"@\";\n\nexport type Err<T1> = {\n\n    /**\n     * ***Brief***\n     * `ok` checks if the current instance is `Ok`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  if (result.ok()) {\n     *      let value: 200n = result.unlock();\n     *      /// ...\n     *  }\n     * ```\n     */\n    ok(): this is Ok<unknown>;\n\n    /**\n     * ***Brief***\n     * `err` checks if the current instance is `Err`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  if (result.err()) {\n     *      let e: 404n = result.inspect();\n     *      /// ...\n     *  }\n     * ```\n     */\n    err(): this is Err<T1>;\n\n    /**\n     * ***Brief***\n     * Retrieves the error value encapsulated by the `Err` instance.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  if (result.err()) {\n     *      let e: 404n = result.inspect();\n     *      /// ...\n     *  }\n     * ```\n     */\n    inspect(): T1;\n\n    /**\n     * ***Brief***\n     * Retrieves the stack trace of the error, generated at the time the `Err` instance was created.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  if (result.err()) {\n     *      result\n     *          .stack()\n     *          .lines()\n     *          .forEach(line => {\n     *              let lineRepresentation: string = line.toString();\n     *              /// ...\n     *              return; \n     *          });\n     *  }\n     * ```\n     */\n    stack(): string;\n\n    /**\n     * ***Brief***\n     * `expect` terminates with `panic` if the `Result` is `Err`.\n     * \n     * ***Warning***\n     * Reserved for debugging or unrecoverable errors.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  let status: 200n = result.expect(\"This is unexpected and unrecoverable.\");\n     * ```\n     */\n    expect(): never;\n    expect(message: string): never;\n    expect(message?: string): never;\n\n    /**\n     * ***Brief***\n     * Ensures that the `Result` is an `Err` and retrieves the error value inside.\n     * \n     * ***Warning***\n     * Reserved for debugging or unrecoverable errors.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  let status: 404n = result.expectErr(\"This is unexpected and unrecoverable.\");\n     * ```\n    */\n    expectErr(): T1;\n    expectErr(__: unknown): T1;\n    expectErr(__?: unknown): T1;\n\n    /**\n     * ***Brief***\n     * Retrieves the value of an `Ok`, or falls back to the provided value if its an `Err`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  let status: 200n = result.unwrapOr(200n);\n     *  console.log(status); /// 200n.\n     * ```\n     */\n    unwrapOr<T2>(fallback: T2): T2;\n\n    /**\n     * ***Brief***\n     * Chains an task until the first `Err` is encountered.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  result\n     *      .and(value => {\n     *          /// Task is skipped because `Result` is an `Err`.\n     *          /// ...\n     *          return Ok(value + 1n);\n     *      })\n     *      .and(value => {\n     *          /// Task is skipped because `Result` is an `Err`.\n     *          /// ...\n     *      });\n     * ```\n     */\n    and(__: unknown): Err<T1>;\n\n    /**\n     * ***Brief***\n     * Transforms the `Ok` value if present, but if this is already an `Err`, it remains unchanged.\n     * \n     * ***Example***\n     * ```ts\n     *  let result0: Result<200n, 404n> = Ok(200n);\n     *  let result1: Result<201n, 404n> = result.map(value => {\n     *      /// Task is run because `Result` is `Ok`.\n     *      /// ...\n     *      return value + 1n;\n     *  });\n     * ```\n     */\n    map(__: unknown): Err<T1>;\n\n    /**\n     * ***Brief***\n     * Transforms the error contained in the `Err` using the provided `task` function.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  result\n     *      .mapErr(e => {\n     *          return e + 1n;\n     *      })\n     *      .inspect(); /// 405n.\n     * ```\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Ok(200n);\n     *  result\n     *      .mapErr(e => {\n     *          /// Task is run because `Result` is `Ok`.\n     *          /// ...\n     *      });\n     * ```\n     */\n    mapErr<T2>(task: Closure<[T1], T2>): Err<T2>;\n\n    /**\n     * ***Brief***\n     * Recovers from the current error by applying a recovery function, transforming the `Err` into an `Ok`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Err(404n);\n     *  let status: 200n = result\n     *      .recover(() => {\n     *          return 200n;\n     *      })\n     *      .unlock();\n     * ```\n     */\n    recover<T2>(task: Closure<[T1], T2>): Ok<T2>;\n\n    /**\n     * ***Brief***\n     * Applies a transformation to the `Ok` value and returns an `Err` instance with the transformed value.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n> = Ok(200n);\n     *  let e: 404n = result\n     *      .degrade(() => {\n     *          return 404n;\n     *      })\n     *      .inspect();\n     *  console.log(e); /// 404n.\n     * ```\n     */\n    degrade(__: unknown): Err<T1>;\n\n    /**\n     * ***Brief***\n     * Converts a `Result<T1, T2>` to an `Option<T1>`.\n     * \n     * ***Example***\n     * ```ts\n     *  let result: Result<200n, 404n>;\n     *  let option: Option<200n> = result.toOption();\n     * ```\n     */\n    toOption(): Option<never>;\n};\n\n/**\n * ***Brief***\n * The failed state of a `Result`.\n * \n * ***Warning***\n * Any operation attempting to access a `Result` must safely handle the `Err` state or terminate with an error.\n */\nexport function Err<T1>(_value: T1): Err<T1>;\nexport function Err<T1>(_value: T1, _handler: Error.Handler): Err<T1>;\nexport function Err<T1>(\n    _p0: T1,\n    _p1?: Error.Handler\n): Err<T1> {\n    let _this: Err<T1>;\n    let _stack: string;\n    let _value: T1;\n    let _handler: Error.Handler;\n    \n    /** @constructor */ {\n        _value = _p0;\n        _handler = _p1 ?? Error.Handler;\n        _stack = _handler.localStackTrace(Err).unwrapOr(\"\");\n        return _this = {\n            ok,\n            err,\n            inspect,\n            stack,\n            expect,\n            expectErr,\n            unwrapOr,\n            and,\n            map,\n            mapErr,\n            recover,\n            degrade,\n            toOption\n        };\n    }\n\n    function ok(): this is Ok<unknown> {\n        return false;\n    }\n\n    function err(): this is Err<T1> {\n        return true;\n    }\n\n    function inspect(): T1 {\n        return _value;\n    }\n\n    function stack(): string {\n        return _stack;\n    }\n\n    function expect(): never;\n    function expect(message: string): never;\n    function expect(message?: string): never {\n        let e: T1 = inspect();\n        if (typeof e === \"string\") {\n            if (e.includes(\".\")) {\n                if (\n                    e.split(\".\")\n                        ?.at(1)\n                        ?.startsWith(\"ERR\")\n                ) Error.Handler.panic(e, expect);\n            }\n            else {\n                if (e.startsWith(\"ERR\")) Error.Handler.panic(e, expect);\n            }\n        }\n        if (typeof e === \"string\") {\n            if (\n                e.includes(\".\")\n                && e.split(\".\")\n                    ?.at(1)\n                    ?.startsWith(\"ERR\")\n            ) Error.Handler.panic(e, expect);\n        }\n        if (e instanceof globalThis.Error) {\n            let code: string = e.name;\n            let message$0: string = `${ e.message } ${ message ? `${ message }` : \"\" }`;\n            let stack$0: string = e.stack ?? stack();\n            Error.Handler.panic(Error({\n                code: code,\n                message: message$0,\n                stack: stack$0\n            }));\n        }\n        Error.Handler.match(inspect(), e => {\n            Error.Handler.panic(Error({\n                code: e.code,\n                message: `${ e.message } ${ message ? `${ message }` : \"\" }`,\n                stack: e.stack\n            }))\n        });\n        Error.Handler.panic(Error({\n            code: \"PANIC\",\n            message: `${ message ? message : \"An unrecoverable error has caused the program to panic.\"}`,\n            stack: Error.Handler.localStackTrace(expect).unwrapOr(\"\")\n        }));\n    }\n\n    function expectErr(): T1;\n    function expectErr(__: unknown): T1;\n    function expectErr(__?: unknown): T1 {\n        return inspect();\n    }\n\n    function unwrapOr<T2>(fallback: T2): T2 {\n        return fallback;\n    }\n\n    function and(__: unknown): Err<T1> {\n        return _this;\n    }\n\n    function map(__: unknown): Err<T1> {\n        return _this;\n    }\n\n    function mapErr<T2>(task: Closure<[T1], T2>): Err<T2> {\n        return Err(task(inspect()));\n    }\n\n    function recover<T2>(task: Closure<[T1], T2>): Ok<T2> {\n        return Ok(task(inspect()));\n    }\n\n    function degrade(__: unknown): Err<T1> {\n        return _this;\n    }\n\n    function toOption(): Option<never> {\n        return None;\n    }\n}\n\nexport namespace Err {\n    export type From<T1 extends Result<unknown, unknown>> = T1 extends Err<infer T2> ? Err<T2> : never;\n\n    export type FromAll<T1 extends Array<Result<unknown, unknown>>> = {\n        [T2 in keyof T1]: T1[T2] extends Err<unknown> ? From<T1[T2]> : never\n    };\n\n    export type ValFrom<T1 extends Result<unknown, unknown>> = T1 extends Err<infer T2> ? T2 : never;\n\n    export type ValFromAll<T1 extends Array<Result<unknown, unknown>>> = {\n        [T2 in keyof T1]: ValFrom<T1[T2]>;\n    };\n}","export const INTERNAL_ERROR_MESSAGE: string = \"\"\n    + \"\\n\" + \"Uh-oh, looks like Reliq took a wrong turn!\"\n    + \"\\n\" + \"Don't worry, it's not you-it's us.\"\n    + \"\\n\" + \"Please report this at https://github.com/snqre/reliq\";","import { type Closure } from \"@\";\n\n/**\n * ***Brief***\n * Utility type for creating branded types with a unique string literal identifier `T1`.\n * \n * ***Example***\n * ```ts\n *  type Foo = \n *      & BrandedStruct<\"Foo\">\n *      & {\n *      foo: void;\n *  };\n * \n *  type Bar =\n *      & BrandedStruct<\"Bar\">\n *      & {\n *      foo: void;\n *  };\n * \n *  let union: Foo | Bar;\n *  if (union.type === \"Foo\") {\n *      /// ...\n *  }\n * ```\n */\nexport type BrandedStruct<T1 extends string> = {\n\n    /**\n     * ***Brief***\n     * Type-level marker specifying the unique type identifier `T1`.\n     *\n     * ***Example***\n     * ```ts\n     *  type Foo = \n     *      & BrandedStruct<\"Foo\">\n     *      & {\n     *      foo: void;\n     *  };\n     * \n     *  type Bar =\n     *      & BrandedStruct<\"Bar\">\n     *      & {\n     *      foo: void;\n     *  };\n     * \n     *  let union: Foo | Bar;\n     *  if (union.type === \"Foo\") {\n     *      /// ...\n     *  }\n     * ```\n     */\n    type: T1;\n};\n\nexport namespace BrandedStruct {\n    export type Task<T1 extends string> = Closure<[value: BrandedStruct<T1>], void>;\n\n    export type Handler = {\n        match<T1 extends string = any>(unknown: unknown): unknown is BrandedStruct<T1>;\n        match<T1 extends string = any>(unknown: unknown, task: Task<T1>): unknown is BrandedStruct<T1>;\n        match<T1 extends string>(unknown: unknown, brand: T1): unknown is BrandedStruct<T1>;\n        match<T1 extends string>(unknown: unknown, brand: T1, task: Task<T1>): unknown is BrandedStruct<T1>;\n    };\n\n    export const Handler: Handler = (() => {\n        /** @constructor */ {\n            return { match };\n        }\n\n        function match<T1 extends string = any>(unknown: unknown): unknown is BrandedStruct<T1>;\n        function match<T1 extends string = any>(unknown: unknown, task: Closure<[item: BrandedStruct<T1>], void>): unknown is BrandedStruct<T1>;\n        function match<T1 extends string>(unknown: unknown, brand: T1): unknown is BrandedStruct<T1>;\n        function match<T1 extends string>(unknown: unknown, brand: T1, task: Closure<[item: BrandedStruct<T1>], void>): unknown is BrandedStruct<T1>;\n        function match<T1 extends string>(\n            p0: unknown,\n            p1?: Task<T1> | T1,\n            p2?: Task<T1>\n        ): p0 is BrandedStruct<T1> {\n            let unknown: unknown = p0;\n            if (!_valid(unknown)) return false;\n            if (typeof p1 === \"string\") {\n                let brand: T1 = p1;\n                if (!_valid(unknown, brand)) return false;\n            }\n            let value: BrandedStruct<T1> = (unknown as BrandedStruct<T1>);\n            if (typeof p1 === \"function\") {\n                let task: Task<T1> = p1;\n                task(value);\n                return true;\n            }\n            if (typeof p2 === \"function\") {\n                let task: Task<T1> = p2;\n                task(value);\n                return true;\n            }\n            return true;\n        }\n\n        function _valid<T1 extends string>(unknown: unknown): unknown is BrandedStruct<T1>;\n        function _valid<T1 extends string>(unknown: unknown, brand: T1): unknown is BrandedStruct<T1>;\n        function _valid<T1 extends string>(\n            p0: unknown,\n            p1?: T1\n        ): p0 is BrandedStruct<T1> {\n            let unknown: unknown = p0;\n            if (!(\n                unknown !== null\n                && unknown !== undefined\n                && typeof unknown === \"object\"\n                && \"type\" in unknown\n                && typeof unknown.type === \"string\"\n            )) return false;\n            if (p1 && unknown.type !== p1) return false;\n            return true;\n        }\n    })();\n}","import { type Closure } from \"@\";\n\n/**\n * ***Brief***\n * Utility type for creating branded types with a unique string literal identifier `T1`.\n * \n * ***Example***\n * ```ts\n *  type Foo = \n *      & Branded<\"Foo\">\n *      & {\n *      foo(): void;\n *  };\n * \n *  type Bar =\n *      & Branded<\"Bar\">\n *      & {\n *      foo(): void;\n *  };\n * \n *  let union: Foo | Bar;\n *  if (union.type() === \"Foo\") {\n *      /// ...\n *  }\n * ```\n */\nexport type Branded<T1 extends string> = {\n\n    /**\n     * ***Brief***\n     * Type-level marker method specifying the unique type identifier `T1`.\n     *\n     * ***Example***\n     * ```ts\n     *  type Foo = \n     *      & Branded<\"Foo\">\n     *      & {\n     *      foo(): void;\n     *  };\n     * \n     *  type Bar =\n     *      & Branded<\"Bar\">\n     *      & {\n     *      foo(): void;\n     *  };\n     * \n     *  let union: Foo | Bar;\n     *  if (union.type() === \"Foo\") {\n     *      /// ...\n     *  }\n     * ```\n     */\n    type(): T1;\n};\n\nexport namespace Branded {\n    export type Task<T1 extends string> = Closure<[value: Branded<T1>], void>;\n\n    export type Handler = {\n        match<T1 extends string = any>(unknown: unknown): unknown is Branded<T1>;\n        match<T1 extends string = any>(unknown: unknown, task: Task<T1>): unknown is Branded<T1>;\n        match<T1 extends string>(unknown: unknown, brand: T1): unknown is Branded<T1>;\n        match<T1 extends string>(unknown: unknown, brand: T1, task: Task<T1>): unknown is Branded<T1>;\n    };\n\n    export const Handler: Handler = (() => {\n        /** @constructor */ {\n            return { match };\n        }\n\n        function match<T1 extends string = any>(unknown: unknown): unknown is Branded<T1>;\n        function match<T1 extends string = any>(unknown: unknown, task: Task<T1>): unknown is Branded<T1>;\n        function match<T1 extends string>(unknown: unknown, brand: T1): unknown is Branded<T1>;\n        function match<T1 extends string>(unknown: unknown, brand: T1, task: Task<T1>): unknown is Branded<T1>;\n        function match<T1 extends string>(\n            p0: unknown,\n            p1?: Task<T1> | T1,\n            p2?: Task<T1>\n        ): p0 is Branded<T1> {\n            let unknown: unknown = p0;\n            if (!_valid(unknown)) return false;\n            if (typeof p1 === \"string\") {\n                let brand: T1 = p1;\n                if (!_valid(unknown, brand)) return false;\n            }\n            let value: Branded<T1> = (unknown as Branded<T1>);\n            if (typeof p1 === \"function\") {\n                let task: Task<T1> = p1;\n                task(value);\n                return true;\n            }\n            if (typeof p2 === \"function\") {\n                let task: Task<T1> = p2;\n                task(value);\n                return true;\n            }\n            return true;\n        }\n\n        function _valid<T1 extends string>(unknown: unknown): unknown is Branded<T1>;\n        function _valid<T1 extends string>(unknown: unknown, brand: T1): unknown is Branded<T1>;\n        function _valid<T1 extends string>(\n            p0: unknown,\n            p1?: T1\n        ): p0 is Branded<T1> {\n            let unknown: unknown = p0;\n            if (!(\n                unknown !== null\n                && unknown !== undefined\n                && typeof unknown === \"object\"\n                && \"type\" in unknown\n                && typeof unknown.type === \"function\"\n                && typeof unknown.type() === \"string\"\n            )) return false;\n            if (p1 && unknown.type() !== p1) return false;\n            return true;\n        }\n    })();\n}","import {\n    type Closure,\n    INTERNAL_ERROR_MESSAGE,\n    Option,\n    Some,\n    None,\n} from \"@\";\n\nexport type Dyn<T1> = Alloc<T1> | DeAlloc<T1>;\n\n/**\n * ***Brief***\n * A dynamic resource management pattern, allowing for\n * allocation and deallocation of resources with proper lifecycle handling.\n * \n * ***Warning***\n * The `Dyn` wrapper must be properly managed to avoid memory leaks. If the wrapper itself is garbage collected \n * without its content being explicitly deallocated, the resources it manages will not be recycled \n * and made available for reuse. Ensure all allocated resources are deallocated before the `Dyn` instance goes out of scope.\n * \n * ***Example***\n * ```ts\n *  type Car = {\n *      drive(): void;\n *  };\n * \n *  const Car: DynConstructor<Car, [_model: string]> = Dyn(\n *      (_model: string) => {\n *          constructor {\n *              return { drive };\n *          }\n * \n *          function drive(): void {\n *              return \"Vroom.\";\n *          }\n *      },\n *      car => {\n *          /// Reset car or any tasks before it is made available again.\n *          /// ...\n *          return car;\n *      }, 32n, \"ModelT\"\n *  );\n * \n *  let car: Dyn<Car> = Car(\"ModelF\");\n *  car = car.deAlloc();\n *  car.map(car => {\n *      /// Will not run because `car` has been deallocated.\n *      /// ...\n *  });\n * ```\n * \n * ***Example***\n * ```ts\n *  /// Warning.\n *  let car: Dyn<Car> = Car(\"ModelB\");\n *  car.deAlloc();\n *  car.map(car => {\n *      /// Will run because the car must be updated to the new state.\n *      /// Always assign the `deAlloc` result a new `Dyn` wrapper or\n *      /// itself.\n *      /// ...\n *  });\n * ```\n */\nexport function Dyn<T1, T2 extends Array<unknown>>(_constructor: Closure<T2, T1>, _onDeAlloc: Closure<[T1], T1>, _load: bigint, ..._onLoadPayload: T2): Dyn.Constructor<T1, T2> {\n    let _available: Map<bigint, T1>;\n    let _count: bigint;\n\n    /** @constructor */ {\n        _available = new Map();\n        _count = 0n;\n        let i: bigint = 0n;\n        while (i < _load) {\n            let key: bigint = _newKey();\n            _available.set(key, _constructor(..._onLoadPayload));\n            i ++;\n        }\n        return function (...payload: T2): Dyn<T1> {\n            let _key: Option<bigint>;\n            let _this: Dyn<T1>;\n    \n            /** @constructor */ {\n                _key = None;\n                return _this = alloc();\n            }\n\n            function alloc(): Alloc<T1> {\n                return _recycledKey()\n                    .toResult(undefined)\n                    .map(key => {\n                        _key = Some(key);\n                        return Alloc(_recyled(key), { deAlloc });\n                    })\n                    .recover(() => {\n                        _key = Some(_newKey());\n                        return Alloc(_constructor(...payload), { deAlloc });\n                    })\n                    .unwrap();            \n            }\n    \n            function deAlloc(): DeAlloc<T1> {\n                _key\n                    .toResult(undefined)\n                    .map(key => {\n                        /// If the key is available then it is allocated.\n                        _key = None;\n                        _recyle(key, _onDeAlloc(_this.expect(\"Dyn: Could not deallocate resource but the key was available.\" + INTERNAL_ERROR_MESSAGE)));\n                        return;\n                    });\n                return _this = DeAlloc({ deAlloc });\n            }\n        };\n    }\n\n    function _newKey(): bigint {\n        return _count += 1n;\n    }\n\n    function _recycledKey(): Option<bigint> {\n        let key: bigint | undefined = _available\n            .keys()\n            .toArray()\n            .at(0);\n        if (!key) return None;\n        return Some(key);\n    }\n\n    function _recyled(key: bigint): T1 {\n        let value: T1 = _available.get(key)!;\n        _available.delete(key);\n        return value;\n    }\n\n    function _recyle(key: bigint, value: T1): void {\n        _available.set(key, value);\n        return;\n    }\n}\n\nexport namespace Dyn {\n    export type Constructor<T1, T2 extends Array<unknown>> = Closure<T2, Dyn<T1>>;\n\n    export type Wrapper<T1> = {\n\n        /**\n         * ***Brief***\n         * Deallocates a resource, making it available for recycling.\n         * \n         * ***Example***\n         * ```ts\n         *  let personD: Dyn<{ name: string }>;\n         *  personD\n         *      .deAlloc()\n         *      .map(person => {\n         *          /// Not run because `person` was deallocated.\n         *          /// ...\n         *      });\n         * ```\n         */\n        deAlloc(): DeAlloc<T1>;\n    };\n}\n\n\nexport type Alloc<T1> =\n    & Dyn.Wrapper<T1>\n    & Some<T1>\n    & {\n    /**\n     * ***Brief***\n     * Unwraps the wrapped value of type `T1`.\n     * \n     * ***Requirement***\n     * Does not `panic`.\n     * \n     * ***Example***\n     * ```ts\n     *  let unsafe: Unsafe = Unsafe(500n);\n     *  unsafe.unwrap();\n     * ```\n     */\n    unwrap(): T1;       \n}\n    \nexport function Alloc<T1>(_value: T1, _dyn: Dyn.Wrapper<T1>): Alloc<T1> {\n    {\n        return { ... Some(_value), ... _dyn };\n    }\n}\n\n\nexport type DeAlloc<T1> = \n    & None\n    & Dyn.Wrapper<T1>;\n\n/**\n * ***Brief***\n * The deallocated state of an allocated resource.\n */\nexport function DeAlloc<T1>(_dyn: Dyn.Wrapper<T1>): DeAlloc<T1> {\n    {\n        return { ... None, ... _dyn };\n    }\n}","import {\n    type Closure\n} from \"@\";\n\nexport namespace Ref {\n    export type Task<T1> = Closure<[new: T1, old: T1], void>;\n    \n    export type DeletionTask = Closure<[], void>;\n}\n\nexport type Ref<T1> = {\n\n    /**\n     * ***Brief***\n     * Unwraps the wrapped value of type `T1`.\n     * \n     * ***Requirement***\n     * Does not `panic`.\n     * \n     * ***Example***\n     * ```ts\n     *  let unsafe: Unsafe = Unsafe(500n);\n     *  unsafe.unwrap();\n     * ```\n     */\n    unwrap(): T1;\n\n    /**\n     * ***Brief***\n     * Mutates the internal value of the `Ref` instance.\n     */\n    mut(value: T1): Ref<T1>;\n\n    /**\n     * ***Brief***\n     * Registers a callback that is invoked whenever the value changes.\n     * \n     * ***Example***\n     * ```ts\n     *  let ref: Ref<bigint> = Ref(200n);\n     *  ref.onChange(value => {\n     *      /// ...\n     *      return;\n     *  });\n     *  ref.mut(404n);\n     * ```\n     */\n    onChange(task: Ref.Task<T1>): Ref.DeletionTask;\n};\n\n/**\n * ***Brief***\n * Wrapper that supports mutation and change tracking.\n */\nexport function Ref<T1>(_value: T1): Ref<T1> {\n    let _this: Ref<T1>;\n    let _count: bigint;\n    let _taskMap: Map<bigint, Ref.Task<T1>>;\n\n    /** @constructor */ {\n        _count = 0n;\n        _taskMap = new Map();\n        return _this = { unwrap, mut, onChange };\n    }\n\n    function unwrap(): T1 {\n        return _value;\n    }\n\n    function mut(value: T1): Ref<T1> {\n        let oldValue: T1 = unwrap();\n        let newValue: T1 = value;\n        _value = value;\n        _taskMap\n            .values()\n            .toArray()\n            .forEach(task => {\n                return task(newValue, oldValue);\n            });\n        return _this;\n    }\n\n    function onChange(task: Ref.Task<T1>): Ref.DeletionTask {\n        let key: bigint = _newKey();\n        _taskMap.set(key, task);\n        return () => {\n            _taskMap.delete(key);\n            return;\n        }\n    }\n\n    function _newKey(): bigint {\n        return _count += 1n;\n    }\n}"],"mappings":"AAyCO,SAASA,EAASC,EAA0B,CAC/C,GAAIA,GAAY,MAAiC,OAAOA,GAAY,SAAU,OAAO,OAAOA,CAAO,EACnG,GAAI,CACA,OAAO,KAAK,UAAUA,CAAO,CACjC,MACM,CAAC,CACP,MAAO,iBACX,CC3BO,SAASC,EAAUC,EAAiC,CACvD,OAAOC,EAAK,IACD,gBAAgBD,CAAK,CAC/B,EAAE,OAAOE,GACCA,EACF,MAAOC,GACGA,GAAa,MAEb,OAAOA,GAAa,UACpB,SAAUA,GACV,SAAUA,GACV,YAAaA,GACb,OAAOA,EAAS,MAAS,UACzB,OAAOA,EAAS,MAAS,UACzB,OAAOA,EAAS,SAAY,QACtC,EACA,IAAIC,GACMC,EAASD,CAAS,CAC5B,EACA,SAASC,EAAS,CAAC,CAC3B,CACL,CC8CO,SAASC,EAA6BC,EAAwBC,EAAoC,CAEjG,OAAIC,EAAS,EAAI,GAAWC,EAAI,2BAA2B,EACpDC,EAAG,CACN,OAAAC,EACA,SAAAH,EACA,eAAAI,EACA,GAAAC,EACA,GAAAC,EACA,GAAAC,EACA,KAAAC,EACA,KAAAC,EACA,IAAAC,EACA,IAAAC,EACA,IAAAC,EACA,IAAAC,EACA,IAAAC,EACA,KAAAC,EACA,QAAAC,EACA,aAAAC,EACA,eAAAC,EACA,eAAAC,EACA,iBAAAC,EACA,QAAAC,EACA,cAAAC,EACA,cAAAC,EACA,SAAAC,CACJ,CAAC,EAGL,SAASrB,GAAiB,CACtB,OAAON,EAAI,WAAW,OAAOC,CAAE,CACnC,CAEA,SAASE,GAAe,CACpB,OAAOD,CACX,CAEA,SAASK,GAAyB,CAC9B,OAAO,KAAOJ,EAAS,CAC3B,CAIA,SAASK,EAAGoB,EAAgC,CACxC,OAAO5B,EAAI,WAAW,GAAGC,EAAI2B,CAAC,CAClC,CAIA,SAASnB,EAAGmB,EAAgC,CACxC,OAAO5B,EAAI,WAAW,GAAGC,EAAI2B,CAAC,CAClC,CAIA,SAASlB,EAAGkB,EAAgC,CACxC,OAAO5B,EAAI,WAAW,GAAGC,EAAI2B,CAAC,CAClC,CAIA,SAASjB,EAAKiB,EAAgC,CAC1C,OAAO5B,EAAI,WAAW,KAAKC,EAAI2B,CAAC,CACpC,CAIA,SAAShB,EAAKgB,EAAgC,CAC1C,OAAO5B,EAAI,WAAW,KAAKC,EAAI2B,CAAC,CACpC,CAIA,SAASf,EAAIe,EAAgC,CACzC,OAAO5B,EAAI,WACN,IAAIC,EAAI2B,EAAGzB,EAAS,CAAC,EACrB,OAAO0B,CAAsB,CACtC,CAIA,SAASf,EAAIc,EAAgC,CACzC,OAAO5B,EAAI,WACN,IAAIC,EAAI2B,EAAGzB,EAAS,CAAC,EACrB,OAAO0B,CAAsB,CACtC,CAIA,SAASd,EAAIa,EAAgC,CACzC,OAAO5B,EAAI,WACN,IAAIC,EAAI2B,EAAGzB,EAAS,CAAC,EACrB,OAAO0B,CAAsB,CACtC,CAIA,SAASb,EAAIY,EAA4C,CACrD,OAAO5B,EAAI,WAAW,IAAIC,EAAI2B,EAAGzB,EAAS,CAAC,CAC/C,CAIA,SAASc,EAAIW,EAA4C,CACrD,OAAO5B,EAAI,WAAW,IAAIC,EAAI2B,EAAGzB,EAAS,CAAC,CAC/C,CAEA,SAASe,GAA4B,CACjC,OAAOlB,EAAI,WAAW,KAAKC,EAAIE,EAAS,CAAC,CAC7C,CAEA,SAASgB,EAAiCW,EAAqC,CAC3E,OAAO9B,EAAI,WAAW,QAAQC,EAAIE,EAAS,EAAG2B,CAAU,CAC5D,CAIA,SAASV,EAAaQ,EAA4C,CAC9D,OAAO5B,EAAI,WAAW,aAAaC,EAAI2B,EAAGzB,EAAS,CAAC,CACxD,CAIA,SAASkB,EAAeU,EAAmD,CACvE,OAAO/B,EAAI,WAAW,eAAeC,EAAI8B,EAAU5B,EAAS,CAAC,CACjE,CAIA,SAASmB,EAAeS,EAAmD,CACvE,OAAO/B,EAAI,WAAW,eAAeC,EAAI8B,EAAU5B,EAAS,CAAC,CACjE,CAIA,SAASoB,EAAiBQ,EAAmD,CACzE,OAAO/B,EAAI,WAAW,iBAAiBC,EAAI8B,EAAU5B,EAAS,CAAC,CACnE,CAIA,SAASqB,EAAQQ,EAAqD,CAClE,OAAOhC,EAAI,WAAW,QAAQC,EAAI+B,EAAY7B,EAAS,CAAC,CAC5D,CAIA,SAASsB,EAAcO,EAAqD,CACxE,OAAOhC,EAAI,WAAW,cAAcC,EAAI+B,EAAY7B,EAAS,CAAC,CAClE,CAIA,SAASuB,EAAcM,EAAqD,CACxE,OAAOhC,EAAI,WAAW,cAAcC,EAAI+B,EAAY7B,EAAS,CAAC,CAClE,CAEA,SAASwB,GAAmB,CACxB,OAAO,OAAO1B,CAAE,EAAI,OAAO,KAAKE,EAAS,CAAC,CAC9C,CACJ,EAEiBH,GA4GAA,EAAA,YAA0B,IAAM,CAErC,MAAO,CACH,OAAAM,EACA,GAAAE,EACA,GAAAC,EACA,GAAAC,EACA,KAAAC,EACA,KAAAC,EACA,IAAAC,EACA,IAAAC,EACA,IAAAC,EACA,IAAAC,EACA,IAAAC,EACA,KAAAC,EACA,QAAAC,EACA,aAAAC,EACA,eAAAC,EACA,eAAAC,EACA,iBAAAC,EACA,QAAAC,EACA,cAAAC,EACA,cAAAC,CACJ,EAGJ,SAASpB,EAAO2B,EAAqC,CACjD,OAAO,OAAOA,GAAU,SAAWA,EAAQA,EAAM,OAAO,CAC5D,CAMA,SAASzB,EAA4CoB,EAAmBM,EAA4B,CAChG,OAAO5B,EAAOsB,CAAC,IAAMtB,EAAO4B,CAAC,CACjC,CAMA,SAASzB,EAA4CmB,EAAmBM,EAA4B,CAChG,OAAO5B,EAAOsB,CAAC,EAAItB,EAAO4B,CAAC,CAC/B,CAMA,SAASxB,EAA4CkB,EAAmBM,EAA4B,CAChG,OAAO5B,EAAOsB,CAAC,EAAItB,EAAO4B,CAAC,CAC/B,CAMA,SAASvB,EAA8CiB,EAAmBM,EAA4B,CAClG,OAAO5B,EAAOsB,CAAC,GAAKtB,EAAO4B,CAAC,CAChC,CAMA,SAAStB,EAA8CgB,EAAmBM,EAA4B,CAClG,OAAO5B,EAAOsB,CAAC,GAAKtB,EAAO4B,CAAC,CAChC,CAMA,SAASrB,EAA6Ce,EAAmBM,EAAmB/B,EAA+B,CACvH,OAAOH,EAAQM,EAAOsB,CAAC,EAAItB,EAAO4B,CAAC,EAAG/B,CAAQ,CAClD,CAMA,SAASW,EAA6Cc,EAAmBM,EAAmB/B,EAA+B,CACvH,OAAOH,EAAQM,EAAOsB,CAAC,EAAItB,EAAO4B,CAAC,EAAG/B,CAAQ,CAClD,CAMA,SAASY,EAA6Ca,EAAmBM,EAAmB/B,EAA+B,CACvH,IAAIgC,EAAc7B,EAAOsB,CAAC,EACtBQ,EAAc9B,EAAO4B,CAAC,EACtBG,EAAYF,EAAMC,EACtB,OAA4BpC,EAAxBG,IAAa,GAAmBkC,EACrBA,EAAK,KAAOlC,EADYA,CAAQ,CAEnD,CAMA,SAASa,EAA6CY,EAAmBM,EAAmB/B,EAA+B,CACvH,IAAIgC,EAAc7B,EAAOsB,CAAC,EACtBQ,EAAc9B,EAAO4B,CAAC,EAC1B,GAAIE,IAAQ,GAAI,OAAOhC,EAAI,0BAA0B,EACrD,GAAID,IAAa,GAAI,OAAOE,EAAGL,EAAImC,EAAMC,EAAKjC,CAAQ,EAAE,OAAO0B,CAAsB,CAAC,EAEtF,IAAIS,EADYH,EAAO,KAAOhC,EACViC,EACpB,OAAO/B,EAAGL,EAAIsC,EAAGnC,CAAQ,EAAE,OAAO0B,CAAsB,CAAC,CAC7D,CAMA,SAASZ,EAA6CW,EAAmBM,EAAmB/B,EAA+B,CACvH,IAAIoC,EAAejC,EAAOsB,CAAC,EACvBY,EAAmBlC,EAAO4B,CAAC,EAC/B,GAAIM,EAAW,GAAI,OAAOpC,EAAI,2BAA2B,EACzD,IAAIqC,EAAiB,GACrB,KAAOD,EAAW,IACVA,EAAW,KAAO,KAAIC,EAAUA,EAASF,EAAS,KAAOpC,GAC7DoC,EAAQA,EAAOA,EAAS,KAAOpC,EAC/BqC,GAAY,GAEhB,IAAIE,EAA4BvB,EAAQsB,EAAQ,GAAItC,CAAQ,EAC5D,GAAIuC,EAAS,IAAI,EAAG,OAAOA,EAE3B,IAAIC,EADoBD,EAAS,OAAO,EACR,OAAO,EACvC,OAAO1C,EAAI2C,EAAUxC,CAAQ,CACjC,CAIA,SAASe,EAA0BU,EAAmBzB,EAA+B,CACjF,IAAIgC,EAAc7B,EAAOsB,CAAC,EAC1B,GAAIO,EAAM,GAAI,OAAO/B,EAAI,gCAAgC,EACzD,GAAI+B,IAAQ,GAAI,OAAOnC,EAAI,GAAIG,CAAQ,EACvC,IAAIyC,EAAc,KAAOzC,EACzByC,GAAOT,EACP,IAAIU,EAAcD,EACdV,EACJ,GACIA,EAAIW,EACJA,GAAOX,EAAIU,EAAMV,GAAK,SAEpBW,IAAQX,GACd,OAAOlC,EAAI6C,EAAK1C,CAAQ,CAC5B,CAIA,SAASgB,EAAkDS,EAAmBkB,EAAiBC,EAAkC,CAC7H,GAAID,EAAc,GAAI,OAAO1C,EAAI,2BAA2B,EAC5D,GAAI2C,EAAc,GAAI,OAAO3C,EAAI,2BAA2B,EAC5D,IAAI+B,EAAc7B,EAAOsB,CAAC,EACtBoB,EACJ,OAAID,EAAcD,IACdE,EAAM,MAAQD,EAAcD,GAC5BX,GAAOa,GAEPD,EAAcD,IACdE,EAAM,MAAQF,EAAcC,GAC5BZ,GAAOa,GAEJ3C,EAAGL,EAAImC,EAAKY,CAAW,EAAE,OAAOlB,CAAsB,CAAC,CAClE,CAMA,SAAST,EAAsDQ,EAAmBM,EAAmB/B,EAA+B,CAChI,IAAIgC,EAAc7B,EAAOsB,CAAC,EACtBQ,EAAc9B,EAAO4B,CAAC,EAC1B,OAAOlB,EAAImB,EAAKC,EAAKjC,CAAQ,EACxB,IAAI8B,GACMA,EAAM,OAAO,CACvB,EACA,IAAIA,GACMlB,EAAIkB,EAAO,KAAQ,KAAK9B,EAAWA,CAAQ,CACrD,CACT,CAMA,SAASkB,EAAwD4B,EAA0BlB,EAA0B5B,EAA+B,CAChJ,IAAI+C,EAAqB5C,EAAO2C,CAAQ,EACpCE,EAAqB7C,EAAOyB,CAAQ,EACxC,OAAIoB,GAAcD,EAAmBlD,EAAI,GAAIG,CAAQ,EAC9CW,EAAIqC,EAAYD,EAAY/C,CAAQ,EACtC,IAAI8B,GACMjB,EAAIiB,EAAOiB,EAAY/C,CAAQ,CACzC,EACA,IAAI8B,GACMlB,EAAIkB,EAAO,KAAQ,KAAK9B,EAAWA,CAAQ,CACrD,EACA,OAAOiD,GACGA,CACV,CACT,CAMA,SAAS9B,EAAwD2B,EAA0BlB,EAA0B5B,EAA+B,CAChJ,IAAI+C,EAAqB5C,EAAO2C,CAAQ,EACpCE,EAAqB7C,EAAOyB,CAAQ,EACxC,OAAIoB,GAAcD,EAAmBlD,EAAI,GAAIG,CAAQ,EAC9CW,EAAIqC,EAAYD,EAAY/C,CAAQ,EACtC,IAAI8B,GACMjB,EAAIiB,EAAOiB,EAAY/C,CAAQ,CACzC,EACA,IAAI8B,GACMlB,EAAIkB,EAAO,KAAQ,KAAK9B,EAAWA,CAAQ,CACrD,EACA,OAAOiD,GACGA,CACV,CACT,CAMA,SAAS7B,EAA0D0B,EAA0BlB,EAA0B5B,EAA+B,CAClJ,IAAI+C,EAAqB5C,EAAO2C,CAAQ,EACpCE,EAAqB7C,EAAOyB,CAAQ,EACxC,OAAIoB,GAAcD,EAAmB5B,EAAe4B,EAAYC,EAAYhD,CAAQ,EAC7EkB,EAAe6B,EAAYC,EAAYhD,CAAQ,CAC1D,CAMA,SAASqB,EAAiDI,EAAmBI,EAA4B7B,EAA+B,CACpI,IAAIgC,EAAc7B,EAAOsB,CAAC,EACtByB,EAAuB/C,EAAO0B,CAAU,EACxCK,EAAqBrB,EAAQmB,EAAK,KAAQ,KAAKhC,EAAWA,CAAQ,EACtE,GAAIkC,EAAE,IAAI,EAAG,OAAOA,EACpB,IAAIiB,EAAejB,EAAE,OAAO,EAC5B,OAAOtB,EAAIuC,EAAKD,EAAclD,CAAQ,CAC1C,CAMA,SAASsB,EAAuDG,EAAmBI,EAA4B7B,EAA+B,CAC1I,IAAIgC,EAAc7B,EAAOsB,CAAC,EACtByB,EAAuB/C,EAAO0B,CAAU,EAC5C,OAAOR,EAAQW,EAAKkB,EAAclD,CAAQ,EAAE,IAAI+B,GACrCrB,EAAIsB,EAAKD,EAAG/B,CAAQ,CAC9B,CACL,CAMA,SAASuB,EAAuDE,EAAmBI,EAA4B7B,EAA+B,CAC1I,IAAIgC,EAAc7B,EAAOsB,CAAC,EACtByB,EAAuB/C,EAAO0B,CAAU,EAC5C,OAAOR,EAAQW,EAAKkB,EAAclD,CAAQ,EAAE,IAAI+B,GACrCpB,EAAIqB,EAAKD,EAAG/B,CAAQ,CAC9B,CACL,CACJ,GAAG,GA5XUH,IAAA,IC7OV,IAAUuD,MAuDAA,EAAA,SAAoB,IAAM,CACjC,MAAO,CAAE,KAAAC,EAAM,IAAAC,EAAK,IAAAC,CAAI,EAE1B,SAASF,EAASG,EAA0C,CACxD,OAAIA,IAAU,KAAaC,EACvBD,IAAU,OAAkBC,EACzBC,EAAMF,CAAY,CAC7B,CAEA,SAASF,KAAyCK,EAA0C,CACxF,IAAIC,EAAwB,CAAC,EACzBC,EAAY,EAChB,KAAOA,EAAIF,EAAQ,QAAQ,CACvB,IAAIG,EAA0BH,EAAQ,GAAGE,CAAC,EAC1C,GAAIC,EAAO,KAAK,EAAG,OAAOA,EAC1BF,EAAI,KAAKE,EAAO,OAAO,CAAC,EACxBD,GACJ,CACA,OAAOH,EAAKE,CAA0B,CAC1C,CAEA,SAASL,KAAyCI,EAAkD,CAChG,IAAIE,EAAY,EAChB,KAAOA,EAAIF,EAAQ,QAAQ,CACvB,IAAIG,EAA0BH,EAAQ,GAAGE,CAAC,EAC1C,GAAIC,EAAO,KAAK,EAAG,OAAOA,EAC1BD,GACJ,CACA,OAAOJ,CACX,CACJ,GAAG,GArFUL,IAAA,ICmCV,SAASW,EACZC,EACAC,EACAC,EACa,CACO,CAChB,GAAI,OAAOF,GAAQ,SAAU,CACzB,IAAIG,EAA6CH,EAC7CI,EAAyBC,EAAKF,EAAc,OAAO,EAAE,SAASJ,EAAM,OAAO,EAC/E,MAAO,CACH,KAAM,QACN,KAAMI,EAAc,KACpB,QAASG,EAAO,QAAQ,KAAKH,EAAc,OAAO,EAClD,QAASG,EAAO,QAAQ,KAAKH,EAAc,OAAO,EAClD,MAAOG,EAAO,QAAQ,KAAKH,EAAc,KAAK,EAAE,SAASC,EAAQ,gBAAgBL,CAAK,EAAE,SAAS,EAAE,CAAC,CACxG,CACJ,CACA,MAAO,CACH,KAAM,QACN,KAAMC,EACN,QAASM,EAAO,QAAQ,KAAKL,CAAG,EAChC,QAASK,EAAO,QAAQ,KAAKJ,CAAG,EAChC,MAAOH,EAAM,QAAQ,gBAAgBA,CAAK,EAAE,SAAS,EAAE,CAC3D,CACJ,CACJ,EAEiBA,GAsCAA,EAAA,SAAoB,IAAM,CACnC,IAAIQ,EAGA,OAAOA,EAAQ,CAAE,MAAAC,EAAO,MAAAC,EAAO,gBAAAC,CAAgB,EAOnD,SAASF,EACLG,EACAC,EACAC,EACwB,CACxB,IAAIC,EAAmBH,EACvB,GAAI,CAACI,EAAc,QAAQ,MAAMD,CAAO,EAAG,MAAO,GAClD,GAAI,OAAOF,GAAO,SAAU,CACxB,IAAII,EAAWJ,EACf,GAAI,CAACG,EAAc,QAAQ,MAAMD,EAASE,CAAI,EAAG,MAAO,EAC5D,CACA,IAAIC,EAAoBH,EACxB,OAAI,OAAOF,GAAO,YACOA,EAChBK,CAAK,EACH,KAEP,OAAOJ,GAAO,YACOA,EAChBI,CAAK,EACH,GAGf,CAIA,SAASR,EACLE,EACAC,EACAC,EACK,CACL,GAAI,OAAOF,GAAO,SAAU,CACxB,IAAIO,EAAeP,EACfQ,EAA0BD,EAAE,MAAM,MAAM;AAAA,CAAI,EAChD,MAAAC,EAAO,MAAM,EACbD,EAAE,MAAQC,EAAO,KAAK;AAAA,CAAI,EAC1B,QAAQ,IAAIA,EAAQ,IAAI,EAClB,gBAAsBD,EAAE,IAAK,KAAMA,EAAE,QAAQ,SAAS,EAAE,CAAE;AAAA,EAAuBA,EAAE,KAAM,EACnG,CACA,IAAIF,EAAWL,EACXS,EAAef,EAAMO,CAA2B,EAAE,SAASH,CAAK,EAEhEY,EADmBhB,EAAKQ,CAAE,EAAE,SAASN,CAAK,EAEzC,gBAAgBa,CAAE,EAClB,SAASE,CAAI,EACb,IAAID,GAAS,CACV,IAAIF,EAA0BE,EAAM,MAAM;AAAA,CAAI,EAC9C,OAAAF,EAAO,MAAM,EACNA,EAAO,KAAK;AAAA,CAAI,CAC3B,CAAC,EACA,QAAQ,IACE,aACV,EACA,OAAO,EAEZ,KAAM,gBAAsBH,CAAK;AAAA,EAAuBK,CAAM,EAClE,CAEA,SAASX,EAAgBa,EAAoC,CACzD,IAAIL,EAAyC,WAAW,MAAM,EAE9D,OADA,WAAW,MAAM,kBAAkBA,EAAGK,CAAQ,EAC1CL,EAAE,MAAcM,EAAKN,EAAE,KAAK,EACzBI,CACX,CACJ,GAAG,GAlHUvB,IAAA,IC9DV,SAAS0B,EAAOC,EAAyB,CAExC,MAAO,CAAE,QAAAC,EAAS,MAAAC,CAAM,EAG5B,SAASD,GAAmB,CACxB,OAAOD,CACX,CAEA,SAASE,EAAUC,EAAkC,CACjD,OAAKA,EAAMF,EAAQ,CAAC,EACbG,EAAMH,EAAQ,CAAQ,EADCI,CAElC,CACJ,CCtBO,IAAMC,EAAmCC,EAAO,QAAQ,KAElDC,EAAkCD,EAAO,QAAQ,IAEjDE,EAAkCF,EAAO,QAAQ,IAEjDG,EAAkCC,EAAO,QAAQ,IAEjDC,EAAkCD,EAAO,QAAQ,IAEjDE,EAAmCF,EAAO,QAAQ,KAElDG,EAA6CH,EAAO,QAAQ,UC6HlE,SAASI,EAASC,EAAsB,CAEvC,MAAO,CACH,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,OAAAC,EACA,OAAAC,EACA,SAAAC,EACA,IAAAC,EACA,IAAAC,EACA,SAAAC,CACJ,EAGJ,SAASR,GAAe,CACpB,MAAO,MACX,CAEA,SAASC,GAAyB,CAC9B,MAAO,EACX,CAEA,SAASC,GAAqB,CAC1B,MAAO,EACX,CAIA,SAASC,EAAOM,EAAkB,CAC9B,OAAOV,CACX,CAEA,SAASK,GAAa,CAClB,OAAOL,CACX,CAEA,SAASM,EAASI,EAAiB,CAC/B,OAAOV,CACX,CAEA,SAASO,EAAQI,EAA6C,CAC1D,OAAOA,EAAKX,CAAM,CACtB,CAEA,SAASQ,EAAQG,EAAmC,CAChD,OAAOZ,EAAKY,EAAKX,CAAM,CAAC,CAC5B,CAEA,SAASS,EAASC,EAAqB,CACnC,OAAOE,EAAGZ,CAAM,CACpB,CACJ,CC5LO,SAASa,EACZC,EACQ,CACR,CACI,IAAI,EAA8BA,EAClC,OAAI,EAAUC,EAAMC,EAAO,CAAC,EAAG,EAAE,OAAO,EACjCD,EAAM,iBAAiB,CAClC,CAEA,SAASC,EAAO,EAAgC,CAC5C,IAAIC,EAAsB,kBAC1B,OACI,EAAE,OAAS,GACR,EAAE,OAAS,GACX,EAAE,OAAS,GACX,EAAE,OAAS,GACX,EAAE,OAAS,GACX,EAAE,OAAS,GACX,EAAE,OAAS,GACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,IACX,EAAE,OAAS,GAChBA,EAAOJ,EAAS,UAAU,UAAU,EAAE,IAAI,GAExC,EAAE,OAAS,iBACR,EAAE,OAAS,oBACX,EAAE,OAAS,gBACX,EAAE,OAAS,mBACX,EAAE,OAAS,aACX,EAAE,OAAS,4BACX,EAAE,OAAS,iBACX,EAAE,OAAS,gBACX,EAAE,OAAS,kBACX,EAAE,OAAS,qBAChBI,EAAOJ,EAAS,UAAU,UAAU,EAAE,IAAI,GACrCI,CACX,CACJ,EAEiBJ,GAAV,CAmCI,IAAUK,OACAA,EAAA,UAAyC,CAClD,cAAiB,mBACjB,iBAAoB,uBACpB,aAAgB,kBAChB,gBAAmB,qBACnB,UAAa,eACb,yBAA4B,+BAC5B,cAAiB,oBACjB,aAAgB,kBAChB,eAAkB,oBAClB,gBAAmB,qBACvB,EAEaA,EAAA,UAAyC,CAClD,EAAG,qBACH,EAAG,4BACH,EAAG,yBACH,EAAG,4BACH,EAAG,kCACH,EAAG,oBACH,EAAG,wBACH,GAAI,wBACJ,GAAI,iBACJ,GAAI,+BACJ,GAAI,oBACJ,GAAI,wBACJ,GAAI,mBACJ,GAAI,kBACJ,GAAI,gBACJ,GAAI,uBACJ,GAAI,yBACJ,GAAI,kBACJ,GAAI,4BACJ,GAAI,oBACR,IAnCaA,EAAAL,EAAA,kBAnCJA,IAAA,ICyEV,IAAMM,GAAc,IAAM,CAC7B,IAAIC,EAGA,OAAOA,EAAQ,CACX,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,OAAAC,EACA,SAAAC,EACA,IAAAC,EACA,IAAAC,EACA,SAAAC,CACJ,EAGJ,SAASP,GAAe,CACpB,MAAO,MACX,CAEA,SAASC,GAA8B,CACnC,MAAO,EACX,CAEA,SAASC,GAAqB,CAC1B,MAAO,EACX,CAIA,SAASC,EAAOK,EAAyB,CACrCC,EAAM,QAAQ,MAAMA,EAAM,CACtB,KAAM,QACN,QAAS,GAAID,GAAoB,kDAAkD,GACnF,MAAOC,EAAM,QAAQ,gBAAgBN,CAAM,EAAE,SAAS,EAAE,CAC5D,CAAC,CAAC,CACN,CAEA,SAASC,EAAaM,EAAkB,CACpC,OAAOA,CACX,CAEA,SAASL,EAAIM,EAAmB,CAC5B,OAAOZ,CACX,CAEA,SAASO,EAAIK,EAAmB,CAC5B,OAAOZ,CACX,CAEA,SAASQ,EAAaK,EAAgB,CAClC,OAAOC,EAAID,CAAC,CAChB,CACJ,GAAG,ECsCI,SAASE,EAAOC,EAAoB,CACvC,IAAIC,EAGA,OAAOA,EAAQ,CACX,GAAAC,EACA,IAAAC,EACA,OAAAC,EACA,UAAAC,EACA,OAAAC,EACA,SAAAC,EACA,IAAAC,EACA,IAAAC,EACA,OAAAC,EACA,QAAAC,EACA,QAAAC,EACA,SAAAC,CACJ,EAGJ,SAASX,GAAqB,CAC1B,MAAO,EACX,CAEA,SAASC,GAA4B,CACjC,MAAO,EACX,CAIA,SAASC,EAAOU,EAAkB,CAC9B,OAAOR,EAAO,CAClB,CAIA,SAASD,EAAUU,EAAyB,CACxCC,EAAM,QAAQ,MAAMA,EAAM,QAASD,CAAO,CAAC,CAC/C,CAEA,SAAST,GAAa,CAClB,OAAON,CACX,CAEA,SAASO,EAASO,EAAiB,CAC/B,OAAOR,EAAO,CAClB,CAKA,SAASE,EAAYS,EAAqD,CACtE,OAAOA,EAAKX,EAAO,CAAC,CACxB,CAEA,SAASG,EAAQQ,EAAiC,CAC9C,OAAOlB,EAAGkB,EAAKX,EAAO,CAAC,CAAC,CAC5B,CAEA,SAASI,EAAOI,EAAqB,CACjC,OAAOb,CACX,CAEA,SAASU,EAAQG,EAAqB,CAClC,OAAOb,CACX,CAEA,SAASW,EAAYK,EAAkC,CACnD,OAAOC,EAAID,EAAKX,EAAO,CAAC,CAAC,CAC7B,CAEA,SAASO,GAAuB,CAC5B,OAAOM,EAAKb,EAAO,CAAC,CACxB,CACJ,CCvQO,IAAUc,MAoFAA,EAAA,SAAoB,IAAM,CAE/B,MAAO,CAAE,IAAAC,EAAK,IAAAC,EAAK,KAAAC,EAAM,UAAAC,CAAU,EAGvC,SAASH,EAAwCI,EAAoE,CACjH,IAAIC,EAAwB,CAAC,EACzBC,EAAY,EAChB,KAAOA,EAAIF,EAAQ,QAAQ,CACvB,IAAIG,EAAmCH,EAAQ,GAAGE,CAAC,EACnD,GAAIC,EAAO,GAAG,EAAGF,EAAI,KAAKE,EAAO,OAAO,CAAC,MACpC,QAAOA,EACZD,GACJ,CACA,OAAOE,EAAIH,CAAyB,CACxC,CAEA,SAASJ,EAAwCG,EAAoE,CACjH,IAAIC,EAAwB,CAAC,EACzBC,EAAY,EAChB,KAAOA,EAAIF,EAAQ,QAAQ,CACvB,IAAIK,EAAoCL,EAAQ,GAAGE,CAAC,EACpD,GAAIG,EAAQ,GAAG,EAAG,OAAOA,EACpBJ,EAAI,KAAKI,EAAQ,QAAQ,CAAC,EAC/BH,GACJ,CACA,OAAOI,EAAKL,CAA0B,CAC1C,CAEA,SAASH,EAAqCS,KAA0BC,EAAiC,CACrG,GAAI,CACA,OAAOJ,EAAGG,EAAK,GAAGC,CAAO,CAAC,CAC9B,OACOC,EAAG,CACN,OAAOH,EAAII,EAAOD,CAAC,CAAC,CACxB,CACJ,CAEA,eAAeV,EAA0CQ,KAA+BC,EAA0C,CAC9H,GAAI,CACA,OAAOJ,EAAI,MAAMG,EAAK,GAAGC,CAAO,CAAE,CACtC,OACOC,EAAG,CACN,OAAOH,EAAII,EAAOD,CAAC,CAAC,CACxB,CACJ,CACJ,GAAG,GAlIUd,IAAA,ICoNV,SAASgB,EACZC,EACAC,EACO,CACP,IAAIC,EACAC,EACAC,EACAC,EAGA,OAAAD,EAASJ,EACTK,EAAWJ,GAAOK,EAAM,QACxBH,EAASE,EAAS,gBAAgBN,CAAG,EAAE,SAAS,EAAE,EAC3CG,EAAQ,CACX,GAAAK,EACA,IAAAC,EACA,QAAAC,EACA,MAAAC,EACA,OAAAC,EACA,UAAAC,EACA,SAAAC,EACA,IAAAC,EACA,IAAAC,EACA,OAAAC,EACA,QAAAC,EACA,QAAAC,EACA,SAAAC,CACJ,EAGJ,SAASZ,GAA0B,CAC/B,MAAO,EACX,CAEA,SAASC,GAAuB,CAC5B,MAAO,EACX,CAEA,SAASC,GAAc,CACnB,OAAOL,CACX,CAEA,SAASM,GAAgB,CACrB,OAAOP,CACX,CAIA,SAASQ,EAAOS,EAAyB,CACrC,IAAIC,EAAQZ,EAAQ,EAqBpB,GApBI,OAAOY,GAAM,WACTA,EAAE,SAAS,GAAG,EAEVA,EAAE,MAAM,GAAG,GACL,GAAG,CAAC,GACJ,WAAW,KAAK,GACxBf,EAAM,QAAQ,MAAMe,EAAGV,CAAM,EAG3BU,EAAE,WAAW,KAAK,GAAGf,EAAM,QAAQ,MAAMe,EAAGV,CAAM,GAG1D,OAAOU,GAAM,UAETA,EAAE,SAAS,GAAG,GACXA,EAAE,MAAM,GAAG,GACR,GAAG,CAAC,GACJ,WAAW,KAAK,GACxBf,EAAM,QAAQ,MAAMe,EAAGV,CAAM,EAE/BU,aAAa,WAAW,MAAO,CAC/B,IAAIC,EAAeD,EAAE,KACjBE,EAAoB,GAAIF,EAAE,OAAQ,IAAKD,EAAU,GAAIA,CAAQ,GAAK,EAAG,GACrEI,EAAkBH,EAAE,OAASX,EAAM,EACvCJ,EAAM,QAAQ,MAAMA,EAAM,CACtB,KAAMgB,EACN,QAASC,EACT,MAAOC,CACX,CAAC,CAAC,CACN,CACAlB,EAAM,QAAQ,MAAMG,EAAQ,EAAGY,GAAK,CAChCf,EAAM,QAAQ,MAAMA,EAAM,CACtB,KAAMe,EAAE,KACR,QAAS,GAAIA,EAAE,OAAQ,IAAKD,EAAU,GAAIA,CAAQ,GAAK,EAAG,GAC1D,MAAOC,EAAE,KACb,CAAC,CAAC,CACN,CAAC,EACDf,EAAM,QAAQ,MAAMA,EAAM,CACtB,KAAM,QACN,QAAS,GAAIc,GAAoB,yDAAyD,GAC1F,MAAOd,EAAM,QAAQ,gBAAgBK,CAAM,EAAE,SAAS,EAAE,CAC5D,CAAC,CAAC,CACN,CAIA,SAASC,EAAUa,EAAkB,CACjC,OAAOhB,EAAQ,CACnB,CAEA,SAASI,EAAaa,EAAkB,CACpC,OAAOA,CACX,CAEA,SAASZ,EAAIW,EAAsB,CAC/B,OAAOvB,CACX,CAEA,SAASa,EAAIU,EAAsB,CAC/B,OAAOvB,CACX,CAEA,SAASc,EAAWW,EAAkC,CAClD,OAAO5B,EAAI4B,EAAKlB,EAAQ,CAAC,CAAC,CAC9B,CAEA,SAASQ,EAAYU,EAAiC,CAClD,OAAOC,EAAGD,EAAKlB,EAAQ,CAAC,CAAC,CAC7B,CAEA,SAASS,EAAQO,EAAsB,CACnC,OAAOvB,CACX,CAEA,SAASiB,GAA0B,CAC/B,OAAOU,CACX,CACJ,CCjXO,IAAMC,EAAiC;AAAA;AAAA;sDCuDvC,IAAUC,MAUAA,EAAA,SAAoB,IAAM,CAE/B,MAAO,CAAE,MAAAC,CAAM,EAOnB,SAASA,EACLC,EACAC,EACAC,EACuB,CACvB,IAAIC,EAAmBH,EAEvB,GADI,CAACI,EAAOD,CAAO,GACf,OAAOF,GAAO,UAEV,CAACG,EAAOD,EADIF,CACU,EAAG,MAAO,GAExC,IAAII,EAA4BF,EAChC,OAAI,OAAOF,GAAO,YACOA,EAChBI,CAAK,EACH,KAEP,OAAOH,GAAO,YACOA,EAChBG,CAAK,EACH,GAGf,CAIA,SAASD,EACLJ,EACAC,EACuB,CACvB,IAAIE,EAAmBH,EAQvB,MAPI,IACAG,GAAY,MAET,OAAOA,GAAY,UACnB,SAAUA,GACV,OAAOA,EAAQ,MAAS,WAE3BF,GAAME,EAAQ,OAASF,EAE/B,CACJ,GAAG,GA7DUH,IAAA,ICAV,IAAUQ,MAUAA,EAAA,SAAoB,IAAM,CAE/B,MAAO,CAAE,MAAAC,CAAM,EAOnB,SAASA,EACLC,EACAC,EACAC,EACiB,CACjB,IAAIC,EAAmBH,EAEvB,GADI,CAACI,EAAOD,CAAO,GACf,OAAOF,GAAO,UAEV,CAACG,EAAOD,EADIF,CACU,EAAG,MAAO,GAExC,IAAII,EAAsBF,EAC1B,OAAI,OAAOF,GAAO,YACOA,EAChBI,CAAK,EACH,KAEP,OAAOH,GAAO,YACOA,EAChBG,CAAK,EACH,GAGf,CAIA,SAASD,EACLJ,EACAC,EACiB,CACjB,IAAIE,EAAmBH,EASvB,MARI,IACAG,GAAY,MAET,OAAOA,GAAY,UACnB,SAAUA,GACV,OAAOA,EAAQ,MAAS,YACxB,OAAOA,EAAQ,KAAK,GAAM,WAE7BF,GAAME,EAAQ,KAAK,IAAMF,EAEjC,CACJ,GAAG,GA9DUH,IAAA,ICSV,SAASQ,GAAmCC,EAA+BC,EAA+BC,KAAkBC,EAA6C,CAC5K,IAAIC,EACAC,EAEgB,CAChBD,EAAa,IAAI,IACjBC,EAAS,GACT,IAAIC,EAAY,GAChB,KAAOA,EAAIJ,GAAO,CACd,IAAIK,EAAcC,EAAQ,EAC1BJ,EAAW,IAAIG,EAAKP,EAAa,GAAGG,CAAc,CAAC,EACnDG,GACJ,CACA,OAAO,YAAaG,EAAsB,CACtC,IAAIC,EACAC,EAGA,OAAAD,EAAOE,EACAD,EAAQE,EAAM,EAGzB,SAASA,GAAmB,CACxB,OAAOC,EAAa,EACf,SAAS,MAAS,EAClB,IAAIP,IACDG,EAAOK,EAAKR,CAAG,EACRS,EAAMC,EAASV,CAAG,EAAG,CAAE,QAAAW,CAAQ,CAAC,EAC1C,EACA,QAAQ,KACLR,EAAOK,EAAKP,EAAQ,CAAC,EACdQ,EAAMhB,EAAa,GAAGS,CAAO,EAAG,CAAE,QAAAS,CAAQ,CAAC,EACrD,EACA,OAAO,CAChB,CAEA,SAASA,GAAuB,CAC5B,OAAAR,EACK,SAAS,MAAS,EAClB,IAAIH,GAAO,CAERG,EAAOE,EACPO,EAAQZ,EAAKN,EAAWU,EAAM,OAAO,gEAAkES,CAAsB,CAAC,CAAC,CAEnI,CAAC,EACET,EAAQU,EAAQ,CAAE,QAAAH,CAAQ,CAAC,CACtC,CACJ,CACJ,CAEA,SAASV,GAAkB,CACvB,OAAOH,GAAU,EACrB,CAEA,SAASS,GAA+B,CACpC,IAAIP,EAA0BH,EACzB,KAAK,EACL,QAAQ,EACR,GAAG,CAAC,EACT,OAAKG,EACEQ,EAAKR,CAAG,EADEK,CAErB,CAEA,SAASK,EAASV,EAAiB,CAC/B,IAAIe,EAAYlB,EAAW,IAAIG,CAAG,EAClC,OAAAH,EAAW,OAAOG,CAAG,EACde,CACX,CAEA,SAASH,EAAQZ,EAAae,EAAiB,CAC3ClB,EAAW,IAAIG,EAAKe,CAAK,CAE7B,CACJ,CA+CO,SAASN,EAAUO,EAAYC,EAAkC,CAEhE,MAAO,CAAE,GAAIT,EAAKQ,CAAM,EAAG,GAAIC,CAAK,CAE5C,CAWO,SAASH,EAAYG,EAAoC,CAExD,MAAO,CAAE,GAAIZ,EAAM,GAAIY,CAAK,CAEpC,CCrJO,SAASC,GAAQC,EAAqB,CACzC,IAAIC,EACAC,EACAC,EAGA,OAAAD,EAAS,GACTC,EAAW,IAAI,IACRF,EAAQ,CAAE,OAAAG,EAAQ,IAAAC,EAAK,SAAAC,CAAS,EAG3C,SAASF,GAAa,CAClB,OAAOJ,CACX,CAEA,SAASK,EAAIE,EAAoB,CAC7B,IAAIC,EAAeJ,EAAO,EACtBK,EAAeF,EACnB,OAAAP,EAASO,EACTJ,EACK,OAAO,EACP,QAAQ,EACR,QAAQO,GACEA,EAAKD,EAAUD,CAAQ,CACjC,EACEP,CACX,CAEA,SAASK,EAASI,EAAsC,CACpD,IAAIC,EAAcC,EAAQ,EAC1B,OAAAT,EAAS,IAAIQ,EAAKD,CAAI,EACf,IAAM,CACTP,EAAS,OAAOQ,CAAG,CAEvB,CACJ,CAEA,SAASC,GAAkB,CACvB,OAAOV,GAAU,EACrB,CACJ","names":["toString","unknown","clone","value","wrap","unsafe","instance","exception","DomError","Fpv","_v","_decimals","decimals","Err","Ok","unwrap","representation","eq","lt","gt","lteq","gteq","add","sub","mul","div","pow","sqrt","convert","percentageOf","percentageGain","percentageLoss","percentageChange","sliceOf","addPercentage","subPercentage","toNumber","x","INTERNAL_ERROR_MESSAGE","decimals$0","newValue","percentage","value","y","x$0","y$0","z","q","base","exponent","result","result$0","result$2","one","x$1","oldDecimals","newDecimals","scl","oldValue","oldValue$0","newValue$0","e","percentage$0","z$0","Option","flag","all","any","value","None","Some","options","out","i","option","Error","_p0","_p1","_p2","configuration","handler","flag","Option","_this","match","panic","localStackTrace","p0","p1","p2","unknown","BrandedStruct","code","value","e","shards","at","stack","None","location","Some","Unsafe","_value","inspect","parse","guard","Some","None","flag","Option","allO","anyO","allR","Result","anyR","wrap","wrapAsync","Some","_value","type","some","none","expect","unwrap","unwrapOr","and","map","toResult","__","task","Ok","DomError","_p0","Error","_match","code","Exception","None","_this","type","some","none","expect","unwrapOr","and","map","toResult","message","Error","fallback","__","e","Err","Ok","_value","_this","ok","err","expect","expectErr","unwrap","unwrapOr","and","map","mapErr","recover","degrade","toOption","__","message","Error","task","Err","Some","Result","all","any","wrap","wrapAsync","results","out","i","result","Ok","wrapper","Err","task","payload","e","Unsafe","Err","_p0","_p1","_this","_stack","_value","_handler","Error","ok","err","inspect","stack","expect","expectErr","unwrapOr","and","map","mapErr","recover","degrade","toOption","message","e","code","message$0","stack$0","__","fallback","task","Ok","None","INTERNAL_ERROR_MESSAGE","BrandedStruct","match","p0","p1","p2","unknown","_valid","value","Branded","match","p0","p1","p2","unknown","_valid","value","Dyn","_constructor","_onDeAlloc","_load","_onLoadPayload","_available","_count","i","key","_newKey","payload","_key","_this","None","alloc","_recycledKey","Some","Alloc","_recyled","deAlloc","_recyle","INTERNAL_ERROR_MESSAGE","DeAlloc","value","_value","_dyn","Ref","_value","_this","_count","_taskMap","unwrap","mut","onChange","value","oldValue","newValue","task","key","_newKey"]}